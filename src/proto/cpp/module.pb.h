// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: module.proto

#ifndef PROTOBUF_INCLUDED_module_2eproto
#define PROTOBUF_INCLUDED_module_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "ast.pb.h"
#include "info.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_module_2eproto 

namespace protobuf_module_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_module_2eproto
namespace proto {
class ModuleDanger;
class ModuleDangerDefaultTypeInternal;
extern ModuleDangerDefaultTypeInternal _ModuleDanger_default_instance_;
class ModuleFlow;
class ModuleFlowDefaultTypeInternal;
extern ModuleFlowDefaultTypeInternal _ModuleFlow_default_instance_;
class ModuleFlow_FlowInfo;
class ModuleFlow_FlowInfoDefaultTypeInternal;
extern ModuleFlow_FlowInfoDefaultTypeInternal _ModuleFlow_FlowInfo_default_instance_;
class ModuleResult;
class ModuleResultDefaultTypeInternal;
extern ModuleResultDefaultTypeInternal _ModuleResult_default_instance_;
class ModuleSink;
class ModuleSinkDefaultTypeInternal;
extern ModuleSinkDefaultTypeInternal _ModuleSink_default_instance_;
class ModuleSource;
class ModuleSourceDefaultTypeInternal;
extern ModuleSourceDefaultTypeInternal _ModuleSource_default_instance_;
class ModuleStatic;
class ModuleStaticDefaultTypeInternal;
extern ModuleStaticDefaultTypeInternal _ModuleStatic_default_instance_;
class ModuleSummary;
class ModuleSummaryDefaultTypeInternal;
extern ModuleSummaryDefaultTypeInternal _ModuleSummary_default_instance_;
class ModuleTaintWrapper;
class ModuleTaintWrapperDefaultTypeInternal;
extern ModuleTaintWrapperDefaultTypeInternal _ModuleTaintWrapper_default_instance_;
class ModuleTaintWrapper_TaintPoint;
class ModuleTaintWrapper_TaintPointDefaultTypeInternal;
extern ModuleTaintWrapper_TaintPointDefaultTypeInternal _ModuleTaintWrapper_TaintPoint_default_instance_;
class ModuleTaintWrapper_TaintRule;
class ModuleTaintWrapper_TaintRuleDefaultTypeInternal;
extern ModuleTaintWrapper_TaintRuleDefaultTypeInternal _ModuleTaintWrapper_TaintRule_default_instance_;
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::ModuleDanger* Arena::CreateMaybeMessage<::proto::ModuleDanger>(Arena*);
template<> ::proto::ModuleFlow* Arena::CreateMaybeMessage<::proto::ModuleFlow>(Arena*);
template<> ::proto::ModuleFlow_FlowInfo* Arena::CreateMaybeMessage<::proto::ModuleFlow_FlowInfo>(Arena*);
template<> ::proto::ModuleResult* Arena::CreateMaybeMessage<::proto::ModuleResult>(Arena*);
template<> ::proto::ModuleSink* Arena::CreateMaybeMessage<::proto::ModuleSink>(Arena*);
template<> ::proto::ModuleSource* Arena::CreateMaybeMessage<::proto::ModuleSource>(Arena*);
template<> ::proto::ModuleStatic* Arena::CreateMaybeMessage<::proto::ModuleStatic>(Arena*);
template<> ::proto::ModuleSummary* Arena::CreateMaybeMessage<::proto::ModuleSummary>(Arena*);
template<> ::proto::ModuleTaintWrapper* Arena::CreateMaybeMessage<::proto::ModuleTaintWrapper>(Arena*);
template<> ::proto::ModuleTaintWrapper_TaintPoint* Arena::CreateMaybeMessage<::proto::ModuleTaintWrapper_TaintPoint>(Arena*);
template<> ::proto::ModuleTaintWrapper_TaintRule* Arena::CreateMaybeMessage<::proto::ModuleTaintWrapper_TaintRule>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {

// ===================================================================

class ModuleSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleSource) */ {
 public:
  ModuleSource();
  virtual ~ModuleSource();

  ModuleSource(const ModuleSource& from);

  inline ModuleSource& operator=(const ModuleSource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleSource(ModuleSource&& from) noexcept
    : ModuleSource() {
    *this = ::std::move(from);
  }

  inline ModuleSource& operator=(ModuleSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleSource* internal_default_instance() {
    return reinterpret_cast<const ModuleSource*>(
               &_ModuleSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ModuleSource* other);
  friend void swap(ModuleSource& a, ModuleSource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleSource* New() const final {
    return CreateMaybeMessage<ModuleSource>(NULL);
  }

  ModuleSource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleSource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleSource& from);
  void MergeFrom(const ModuleSource& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode reachable_sources = 2;
  int reachable_sources_size() const;
  void clear_reachable_sources();
  static const int kReachableSourcesFieldNumber = 2;
  ::proto::AstNode* mutable_reachable_sources(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_reachable_sources();
  const ::proto::AstNode& reachable_sources(int index) const;
  ::proto::AstNode* add_reachable_sources();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      reachable_sources() const;

  // .proto.AstNode node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  private:
  const ::proto::AstNode& _internal_node() const;
  public:
  const ::proto::AstNode& node() const;
  ::proto::AstNode* release_node();
  ::proto::AstNode* mutable_node();
  void set_allocated_node(::proto::AstNode* node);

  // @@protoc_insertion_point(class_scope:proto.ModuleSource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > reachable_sources_;
  ::proto::AstNode* node_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleSink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleSink) */ {
 public:
  ModuleSink();
  virtual ~ModuleSink();

  ModuleSink(const ModuleSink& from);

  inline ModuleSink& operator=(const ModuleSink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleSink(ModuleSink&& from) noexcept
    : ModuleSink() {
    *this = ::std::move(from);
  }

  inline ModuleSink& operator=(ModuleSink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleSink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleSink* internal_default_instance() {
    return reinterpret_cast<const ModuleSink*>(
               &_ModuleSink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ModuleSink* other);
  friend void swap(ModuleSink& a, ModuleSink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleSink* New() const final {
    return CreateMaybeMessage<ModuleSink>(NULL);
  }

  ModuleSink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleSink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleSink& from);
  void MergeFrom(const ModuleSink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleSink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode reachable_sinks = 2;
  int reachable_sinks_size() const;
  void clear_reachable_sinks();
  static const int kReachableSinksFieldNumber = 2;
  ::proto::AstNode* mutable_reachable_sinks(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_reachable_sinks();
  const ::proto::AstNode& reachable_sinks(int index) const;
  ::proto::AstNode* add_reachable_sinks();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      reachable_sinks() const;

  // .proto.AstNode node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  private:
  const ::proto::AstNode& _internal_node() const;
  public:
  const ::proto::AstNode& node() const;
  ::proto::AstNode* release_node();
  ::proto::AstNode* mutable_node();
  void set_allocated_node(::proto::AstNode* node);

  // @@protoc_insertion_point(class_scope:proto.ModuleSink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > reachable_sinks_;
  ::proto::AstNode* node_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleTaintWrapper_TaintPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleTaintWrapper.TaintPoint) */ {
 public:
  ModuleTaintWrapper_TaintPoint();
  virtual ~ModuleTaintWrapper_TaintPoint();

  ModuleTaintWrapper_TaintPoint(const ModuleTaintWrapper_TaintPoint& from);

  inline ModuleTaintWrapper_TaintPoint& operator=(const ModuleTaintWrapper_TaintPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleTaintWrapper_TaintPoint(ModuleTaintWrapper_TaintPoint&& from) noexcept
    : ModuleTaintWrapper_TaintPoint() {
    *this = ::std::move(from);
  }

  inline ModuleTaintWrapper_TaintPoint& operator=(ModuleTaintWrapper_TaintPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleTaintWrapper_TaintPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleTaintWrapper_TaintPoint* internal_default_instance() {
    return reinterpret_cast<const ModuleTaintWrapper_TaintPoint*>(
               &_ModuleTaintWrapper_TaintPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ModuleTaintWrapper_TaintPoint* other);
  friend void swap(ModuleTaintWrapper_TaintPoint& a, ModuleTaintWrapper_TaintPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleTaintWrapper_TaintPoint* New() const final {
    return CreateMaybeMessage<ModuleTaintWrapper_TaintPoint>(NULL);
  }

  ModuleTaintWrapper_TaintPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleTaintWrapper_TaintPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleTaintWrapper_TaintPoint& from);
  void MergeFrom(const ModuleTaintWrapper_TaintPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleTaintWrapper_TaintPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string access_paths = 2;
  int access_paths_size() const;
  void clear_access_paths();
  static const int kAccessPathsFieldNumber = 2;
  const ::std::string& access_paths(int index) const;
  ::std::string* mutable_access_paths(int index);
  void set_access_paths(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_access_paths(int index, ::std::string&& value);
  #endif
  void set_access_paths(int index, const char* value);
  void set_access_paths(int index, const char* value, size_t size);
  ::std::string* add_access_paths();
  void add_access_paths(const ::std::string& value);
  #if LANG_CXX11
  void add_access_paths(::std::string&& value);
  #endif
  void add_access_paths(const char* value);
  void add_access_paths(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& access_paths() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_access_paths();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.ModuleTaintWrapper.TaintPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> access_paths_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleTaintWrapper_TaintRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleTaintWrapper.TaintRule) */ {
 public:
  ModuleTaintWrapper_TaintRule();
  virtual ~ModuleTaintWrapper_TaintRule();

  ModuleTaintWrapper_TaintRule(const ModuleTaintWrapper_TaintRule& from);

  inline ModuleTaintWrapper_TaintRule& operator=(const ModuleTaintWrapper_TaintRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleTaintWrapper_TaintRule(ModuleTaintWrapper_TaintRule&& from) noexcept
    : ModuleTaintWrapper_TaintRule() {
    *this = ::std::move(from);
  }

  inline ModuleTaintWrapper_TaintRule& operator=(ModuleTaintWrapper_TaintRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleTaintWrapper_TaintRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleTaintWrapper_TaintRule* internal_default_instance() {
    return reinterpret_cast<const ModuleTaintWrapper_TaintRule*>(
               &_ModuleTaintWrapper_TaintRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ModuleTaintWrapper_TaintRule* other);
  friend void swap(ModuleTaintWrapper_TaintRule& a, ModuleTaintWrapper_TaintRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleTaintWrapper_TaintRule* New() const final {
    return CreateMaybeMessage<ModuleTaintWrapper_TaintRule>(NULL);
  }

  ModuleTaintWrapper_TaintRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleTaintWrapper_TaintRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleTaintWrapper_TaintRule& from);
  void MergeFrom(const ModuleTaintWrapper_TaintRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleTaintWrapper_TaintRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.ModuleTaintWrapper.TaintPoint effects = 2;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 2;
  ::proto::ModuleTaintWrapper_TaintPoint* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintPoint >*
      mutable_effects();
  const ::proto::ModuleTaintWrapper_TaintPoint& effects(int index) const;
  ::proto::ModuleTaintWrapper_TaintPoint* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintPoint >&
      effects() const;

  // .proto.ModuleTaintWrapper.TaintPoint cause = 1;
  bool has_cause() const;
  void clear_cause();
  static const int kCauseFieldNumber = 1;
  private:
  const ::proto::ModuleTaintWrapper_TaintPoint& _internal_cause() const;
  public:
  const ::proto::ModuleTaintWrapper_TaintPoint& cause() const;
  ::proto::ModuleTaintWrapper_TaintPoint* release_cause();
  ::proto::ModuleTaintWrapper_TaintPoint* mutable_cause();
  void set_allocated_cause(::proto::ModuleTaintWrapper_TaintPoint* cause);

  // @@protoc_insertion_point(class_scope:proto.ModuleTaintWrapper.TaintRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintPoint > effects_;
  ::proto::ModuleTaintWrapper_TaintPoint* cause_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleTaintWrapper : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleTaintWrapper) */ {
 public:
  ModuleTaintWrapper();
  virtual ~ModuleTaintWrapper();

  ModuleTaintWrapper(const ModuleTaintWrapper& from);

  inline ModuleTaintWrapper& operator=(const ModuleTaintWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleTaintWrapper(ModuleTaintWrapper&& from) noexcept
    : ModuleTaintWrapper() {
    *this = ::std::move(from);
  }

  inline ModuleTaintWrapper& operator=(ModuleTaintWrapper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleTaintWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleTaintWrapper* internal_default_instance() {
    return reinterpret_cast<const ModuleTaintWrapper*>(
               &_ModuleTaintWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ModuleTaintWrapper* other);
  friend void swap(ModuleTaintWrapper& a, ModuleTaintWrapper& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleTaintWrapper* New() const final {
    return CreateMaybeMessage<ModuleTaintWrapper>(NULL);
  }

  ModuleTaintWrapper* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleTaintWrapper>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleTaintWrapper& from);
  void MergeFrom(const ModuleTaintWrapper& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleTaintWrapper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleTaintWrapper_TaintPoint TaintPoint;
  typedef ModuleTaintWrapper_TaintRule TaintRule;

  // accessors -------------------------------------------------------

  // repeated .proto.ModuleTaintWrapper.TaintRule rules = 2;
  int rules_size() const;
  void clear_rules();
  static const int kRulesFieldNumber = 2;
  ::proto::ModuleTaintWrapper_TaintRule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintRule >*
      mutable_rules();
  const ::proto::ModuleTaintWrapper_TaintRule& rules(int index) const;
  ::proto::ModuleTaintWrapper_TaintRule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintRule >&
      rules() const;

  // .proto.AstNode node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  private:
  const ::proto::AstNode& _internal_node() const;
  public:
  const ::proto::AstNode& node() const;
  ::proto::AstNode* release_node();
  ::proto::AstNode* mutable_node();
  void set_allocated_node(::proto::AstNode* node);

  // @@protoc_insertion_point(class_scope:proto.ModuleTaintWrapper)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintRule > rules_;
  ::proto::AstNode* node_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleFlow_FlowInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleFlow.FlowInfo) */ {
 public:
  ModuleFlow_FlowInfo();
  virtual ~ModuleFlow_FlowInfo();

  ModuleFlow_FlowInfo(const ModuleFlow_FlowInfo& from);

  inline ModuleFlow_FlowInfo& operator=(const ModuleFlow_FlowInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleFlow_FlowInfo(ModuleFlow_FlowInfo&& from) noexcept
    : ModuleFlow_FlowInfo() {
    *this = ::std::move(from);
  }

  inline ModuleFlow_FlowInfo& operator=(ModuleFlow_FlowInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleFlow_FlowInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleFlow_FlowInfo* internal_default_instance() {
    return reinterpret_cast<const ModuleFlow_FlowInfo*>(
               &_ModuleFlow_FlowInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ModuleFlow_FlowInfo* other);
  friend void swap(ModuleFlow_FlowInfo& a, ModuleFlow_FlowInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleFlow_FlowInfo* New() const final {
    return CreateMaybeMessage<ModuleFlow_FlowInfo>(NULL);
  }

  ModuleFlow_FlowInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleFlow_FlowInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleFlow_FlowInfo& from);
  void MergeFrom(const ModuleFlow_FlowInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleFlow_FlowInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string cwe = 2;
  void clear_cwe();
  static const int kCweFieldNumber = 2;
  const ::std::string& cwe() const;
  void set_cwe(const ::std::string& value);
  #if LANG_CXX11
  void set_cwe(::std::string&& value);
  #endif
  void set_cwe(const char* value);
  void set_cwe(const char* value, size_t size);
  ::std::string* mutable_cwe();
  ::std::string* release_cwe();
  void set_allocated_cwe(::std::string* cwe);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:proto.ModuleFlow.FlowInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr cwe_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleFlow) */ {
 public:
  ModuleFlow();
  virtual ~ModuleFlow();

  ModuleFlow(const ModuleFlow& from);

  inline ModuleFlow& operator=(const ModuleFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleFlow(ModuleFlow&& from) noexcept
    : ModuleFlow() {
    *this = ::std::move(from);
  }

  inline ModuleFlow& operator=(ModuleFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleFlow* internal_default_instance() {
    return reinterpret_cast<const ModuleFlow*>(
               &_ModuleFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ModuleFlow* other);
  friend void swap(ModuleFlow& a, ModuleFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleFlow* New() const final {
    return CreateMaybeMessage<ModuleFlow>(NULL);
  }

  ModuleFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleFlow& from);
  void MergeFrom(const ModuleFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleFlow_FlowInfo FlowInfo;

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode hops = 2;
  int hops_size() const;
  void clear_hops();
  static const int kHopsFieldNumber = 2;
  ::proto::AstNode* mutable_hops(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_hops();
  const ::proto::AstNode& hops(int index) const;
  ::proto::AstNode* add_hops();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      hops() const;

  // .proto.AstNode source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  private:
  const ::proto::AstNode& _internal_source() const;
  public:
  const ::proto::AstNode& source() const;
  ::proto::AstNode* release_source();
  ::proto::AstNode* mutable_source();
  void set_allocated_source(::proto::AstNode* source);

  // .proto.AstNode sink = 3;
  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 3;
  private:
  const ::proto::AstNode& _internal_sink() const;
  public:
  const ::proto::AstNode& sink() const;
  ::proto::AstNode* release_sink();
  ::proto::AstNode* mutable_sink();
  void set_allocated_sink(::proto::AstNode* sink);

  // .proto.ModuleFlow.FlowInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  private:
  const ::proto::ModuleFlow_FlowInfo& _internal_info() const;
  public:
  const ::proto::ModuleFlow_FlowInfo& info() const;
  ::proto::ModuleFlow_FlowInfo* release_info();
  ::proto::ModuleFlow_FlowInfo* mutable_info();
  void set_allocated_info(::proto::ModuleFlow_FlowInfo* info);

  // @@protoc_insertion_point(class_scope:proto.ModuleFlow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > hops_;
  ::proto::AstNode* source_;
  ::proto::AstNode* sink_;
  ::proto::ModuleFlow_FlowInfo* info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleDanger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleDanger) */ {
 public:
  ModuleDanger();
  virtual ~ModuleDanger();

  ModuleDanger(const ModuleDanger& from);

  inline ModuleDanger& operator=(const ModuleDanger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleDanger(ModuleDanger&& from) noexcept
    : ModuleDanger() {
    *this = ::std::move(from);
  }

  inline ModuleDanger& operator=(ModuleDanger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleDanger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleDanger* internal_default_instance() {
    return reinterpret_cast<const ModuleDanger*>(
               &_ModuleDanger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ModuleDanger* other);
  friend void swap(ModuleDanger& a, ModuleDanger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleDanger* New() const final {
    return CreateMaybeMessage<ModuleDanger>(NULL);
  }

  ModuleDanger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleDanger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleDanger& from);
  void MergeFrom(const ModuleDanger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleDanger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode slices = 2;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 2;
  ::proto::AstNode* mutable_slices(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_slices();
  const ::proto::AstNode& slices(int index) const;
  ::proto::AstNode* add_slices();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      slices() const;

  // .proto.AstNode danger = 1;
  bool has_danger() const;
  void clear_danger();
  static const int kDangerFieldNumber = 1;
  private:
  const ::proto::AstNode& _internal_danger() const;
  public:
  const ::proto::AstNode& danger() const;
  ::proto::AstNode* release_danger();
  ::proto::AstNode* mutable_danger();
  void set_allocated_danger(::proto::AstNode* danger);

  // @@protoc_insertion_point(class_scope:proto.ModuleDanger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > slices_;
  ::proto::AstNode* danger_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleSummary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleSummary) */ {
 public:
  ModuleSummary();
  virtual ~ModuleSummary();

  ModuleSummary(const ModuleSummary& from);

  inline ModuleSummary& operator=(const ModuleSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleSummary(ModuleSummary&& from) noexcept
    : ModuleSummary() {
    *this = ::std::move(from);
  }

  inline ModuleSummary& operator=(ModuleSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleSummary* internal_default_instance() {
    return reinterpret_cast<const ModuleSummary*>(
               &_ModuleSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ModuleSummary* other);
  friend void swap(ModuleSummary& a, ModuleSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleSummary* New() const final {
    return CreateMaybeMessage<ModuleSummary>(NULL);
  }

  ModuleSummary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleSummary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleSummary& from);
  void MergeFrom(const ModuleSummary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.ModuleSource sources = 2;
  int sources_size() const;
  void clear_sources();
  static const int kSourcesFieldNumber = 2;
  ::proto::ModuleSource* mutable_sources(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >*
      mutable_sources();
  const ::proto::ModuleSource& sources(int index) const;
  ::proto::ModuleSource* add_sources();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >&
      sources() const;

  // repeated .proto.ModuleSink sinks = 3;
  int sinks_size() const;
  void clear_sinks();
  static const int kSinksFieldNumber = 3;
  ::proto::ModuleSink* mutable_sinks(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >*
      mutable_sinks();
  const ::proto::ModuleSink& sinks(int index) const;
  ::proto::ModuleSink* add_sinks();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >&
      sinks() const;

  // repeated .proto.ModuleTaintWrapper taint_wrappers = 4;
  int taint_wrappers_size() const;
  void clear_taint_wrappers();
  static const int kTaintWrappersFieldNumber = 4;
  ::proto::ModuleTaintWrapper* mutable_taint_wrappers(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >*
      mutable_taint_wrappers();
  const ::proto::ModuleTaintWrapper& taint_wrappers(int index) const;
  ::proto::ModuleTaintWrapper* add_taint_wrappers();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >&
      taint_wrappers() const;

  // .proto.PackageInfo package_info = 1;
  bool has_package_info() const;
  void clear_package_info();
  static const int kPackageInfoFieldNumber = 1;
  private:
  const ::proto::PackageInfo& _internal_package_info() const;
  public:
  const ::proto::PackageInfo& package_info() const;
  ::proto::PackageInfo* release_package_info();
  ::proto::PackageInfo* mutable_package_info();
  void set_allocated_package_info(::proto::PackageInfo* package_info);

  // @@protoc_insertion_point(class_scope:proto.ModuleSummary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource > sources_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink > sinks_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper > taint_wrappers_;
  ::proto::PackageInfo* package_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleResult) */ {
 public:
  ModuleResult();
  virtual ~ModuleResult();

  ModuleResult(const ModuleResult& from);

  inline ModuleResult& operator=(const ModuleResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleResult(ModuleResult&& from) noexcept
    : ModuleResult() {
    *this = ::std::move(from);
  }

  inline ModuleResult& operator=(ModuleResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleResult* internal_default_instance() {
    return reinterpret_cast<const ModuleResult*>(
               &_ModuleResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ModuleResult* other);
  friend void swap(ModuleResult& a, ModuleResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleResult* New() const final {
    return CreateMaybeMessage<ModuleResult>(NULL);
  }

  ModuleResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleResult& from);
  void MergeFrom(const ModuleResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.ModuleFlow flows = 2;
  int flows_size() const;
  void clear_flows();
  static const int kFlowsFieldNumber = 2;
  ::proto::ModuleFlow* mutable_flows(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >*
      mutable_flows();
  const ::proto::ModuleFlow& flows(int index) const;
  ::proto::ModuleFlow* add_flows();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >&
      flows() const;

  // repeated .proto.ModuleDanger dangers = 3;
  int dangers_size() const;
  void clear_dangers();
  static const int kDangersFieldNumber = 3;
  ::proto::ModuleDanger* mutable_dangers(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >*
      mutable_dangers();
  const ::proto::ModuleDanger& dangers(int index) const;
  ::proto::ModuleDanger* add_dangers();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >&
      dangers() const;

  // .proto.PackageInfo package_info = 1;
  bool has_package_info() const;
  void clear_package_info();
  static const int kPackageInfoFieldNumber = 1;
  private:
  const ::proto::PackageInfo& _internal_package_info() const;
  public:
  const ::proto::PackageInfo& package_info() const;
  ::proto::PackageInfo* release_package_info();
  ::proto::PackageInfo* mutable_package_info();
  void set_allocated_package_info(::proto::PackageInfo* package_info);

  // @@protoc_insertion_point(class_scope:proto.ModuleResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow > flows_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger > dangers_;
  ::proto::PackageInfo* package_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleStatic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ModuleStatic) */ {
 public:
  ModuleStatic();
  virtual ~ModuleStatic();

  ModuleStatic(const ModuleStatic& from);

  inline ModuleStatic& operator=(const ModuleStatic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleStatic(ModuleStatic&& from) noexcept
    : ModuleStatic() {
    *this = ::std::move(from);
  }

  inline ModuleStatic& operator=(ModuleStatic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleStatic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleStatic* internal_default_instance() {
    return reinterpret_cast<const ModuleStatic*>(
               &_ModuleStatic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ModuleStatic* other);
  friend void swap(ModuleStatic& a, ModuleStatic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleStatic* New() const final {
    return CreateMaybeMessage<ModuleStatic>(NULL);
  }

  ModuleStatic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModuleStatic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModuleStatic& from);
  void MergeFrom(const ModuleStatic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleStatic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.ModuleFlow flows = 2;
  int flows_size() const;
  void clear_flows();
  static const int kFlowsFieldNumber = 2;
  ::proto::ModuleFlow* mutable_flows(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >*
      mutable_flows();
  const ::proto::ModuleFlow& flows(int index) const;
  ::proto::ModuleFlow* add_flows();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >&
      flows() const;

  // repeated .proto.ModuleDanger dangers = 3;
  int dangers_size() const;
  void clear_dangers();
  static const int kDangersFieldNumber = 3;
  ::proto::ModuleDanger* mutable_dangers(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >*
      mutable_dangers();
  const ::proto::ModuleDanger& dangers(int index) const;
  ::proto::ModuleDanger* add_dangers();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >&
      dangers() const;

  // repeated .proto.ModuleSource sources = 4;
  int sources_size() const;
  void clear_sources();
  static const int kSourcesFieldNumber = 4;
  ::proto::ModuleSource* mutable_sources(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >*
      mutable_sources();
  const ::proto::ModuleSource& sources(int index) const;
  ::proto::ModuleSource* add_sources();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >&
      sources() const;

  // repeated .proto.ModuleSink sinks = 5;
  int sinks_size() const;
  void clear_sinks();
  static const int kSinksFieldNumber = 5;
  ::proto::ModuleSink* mutable_sinks(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >*
      mutable_sinks();
  const ::proto::ModuleSink& sinks(int index) const;
  ::proto::ModuleSink* add_sinks();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >&
      sinks() const;

  // repeated .proto.ModuleTaintWrapper taint_wrappers = 6;
  int taint_wrappers_size() const;
  void clear_taint_wrappers();
  static const int kTaintWrappersFieldNumber = 6;
  ::proto::ModuleTaintWrapper* mutable_taint_wrappers(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >*
      mutable_taint_wrappers();
  const ::proto::ModuleTaintWrapper& taint_wrappers(int index) const;
  ::proto::ModuleTaintWrapper* add_taint_wrappers();
  const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >&
      taint_wrappers() const;

  // .proto.PackageInfo package_info = 1;
  bool has_package_info() const;
  void clear_package_info();
  static const int kPackageInfoFieldNumber = 1;
  private:
  const ::proto::PackageInfo& _internal_package_info() const;
  public:
  const ::proto::PackageInfo& package_info() const;
  ::proto::PackageInfo* release_package_info();
  ::proto::PackageInfo* mutable_package_info();
  void set_allocated_package_info(::proto::PackageInfo* package_info);

  // @@protoc_insertion_point(class_scope:proto.ModuleStatic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow > flows_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger > dangers_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource > sources_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink > sinks_;
  ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper > taint_wrappers_;
  ::proto::PackageInfo* package_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_module_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModuleSource

// .proto.AstNode node = 1;
inline bool ModuleSource::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline const ::proto::AstNode& ModuleSource::_internal_node() const {
  return *node_;
}
inline const ::proto::AstNode& ModuleSource::node() const {
  const ::proto::AstNode* p = node_;
  // @@protoc_insertion_point(field_get:proto.ModuleSource.node)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstNode*>(
      &::proto::_AstNode_default_instance_);
}
inline ::proto::AstNode* ModuleSource::release_node() {
  // @@protoc_insertion_point(field_release:proto.ModuleSource.node)
  
  ::proto::AstNode* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::proto::AstNode* ModuleSource::mutable_node() {
  
  if (node_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstNode>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleSource.node)
  return node_;
}
inline void ModuleSource::set_allocated_node(::proto::AstNode* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleSource.node)
}

// repeated .proto.AstNode reachable_sources = 2;
inline int ModuleSource::reachable_sources_size() const {
  return reachable_sources_.size();
}
inline ::proto::AstNode* ModuleSource::mutable_reachable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleSource.reachable_sources)
  return reachable_sources_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
ModuleSource::mutable_reachable_sources() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleSource.reachable_sources)
  return &reachable_sources_;
}
inline const ::proto::AstNode& ModuleSource::reachable_sources(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleSource.reachable_sources)
  return reachable_sources_.Get(index);
}
inline ::proto::AstNode* ModuleSource::add_reachable_sources() {
  // @@protoc_insertion_point(field_add:proto.ModuleSource.reachable_sources)
  return reachable_sources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
ModuleSource::reachable_sources() const {
  // @@protoc_insertion_point(field_list:proto.ModuleSource.reachable_sources)
  return reachable_sources_;
}

// -------------------------------------------------------------------

// ModuleSink

// .proto.AstNode node = 1;
inline bool ModuleSink::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline const ::proto::AstNode& ModuleSink::_internal_node() const {
  return *node_;
}
inline const ::proto::AstNode& ModuleSink::node() const {
  const ::proto::AstNode* p = node_;
  // @@protoc_insertion_point(field_get:proto.ModuleSink.node)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstNode*>(
      &::proto::_AstNode_default_instance_);
}
inline ::proto::AstNode* ModuleSink::release_node() {
  // @@protoc_insertion_point(field_release:proto.ModuleSink.node)
  
  ::proto::AstNode* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::proto::AstNode* ModuleSink::mutable_node() {
  
  if (node_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstNode>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleSink.node)
  return node_;
}
inline void ModuleSink::set_allocated_node(::proto::AstNode* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleSink.node)
}

// repeated .proto.AstNode reachable_sinks = 2;
inline int ModuleSink::reachable_sinks_size() const {
  return reachable_sinks_.size();
}
inline ::proto::AstNode* ModuleSink::mutable_reachable_sinks(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleSink.reachable_sinks)
  return reachable_sinks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
ModuleSink::mutable_reachable_sinks() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleSink.reachable_sinks)
  return &reachable_sinks_;
}
inline const ::proto::AstNode& ModuleSink::reachable_sinks(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleSink.reachable_sinks)
  return reachable_sinks_.Get(index);
}
inline ::proto::AstNode* ModuleSink::add_reachable_sinks() {
  // @@protoc_insertion_point(field_add:proto.ModuleSink.reachable_sinks)
  return reachable_sinks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
ModuleSink::reachable_sinks() const {
  // @@protoc_insertion_point(field_list:proto.ModuleSink.reachable_sinks)
  return reachable_sinks_;
}

// -------------------------------------------------------------------

// ModuleTaintWrapper_TaintPoint

// int32 id = 1;
inline void ModuleTaintWrapper_TaintPoint::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ModuleTaintWrapper_TaintPoint::id() const {
  // @@protoc_insertion_point(field_get:proto.ModuleTaintWrapper.TaintPoint.id)
  return id_;
}
inline void ModuleTaintWrapper_TaintPoint::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.ModuleTaintWrapper.TaintPoint.id)
}

// repeated string access_paths = 2;
inline int ModuleTaintWrapper_TaintPoint::access_paths_size() const {
  return access_paths_.size();
}
inline void ModuleTaintWrapper_TaintPoint::clear_access_paths() {
  access_paths_.Clear();
}
inline const ::std::string& ModuleTaintWrapper_TaintPoint::access_paths(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  return access_paths_.Get(index);
}
inline ::std::string* ModuleTaintWrapper_TaintPoint::mutable_access_paths(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  return access_paths_.Mutable(index);
}
inline void ModuleTaintWrapper_TaintPoint::set_access_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  access_paths_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ModuleTaintWrapper_TaintPoint::set_access_paths(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  access_paths_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ModuleTaintWrapper_TaintPoint::set_access_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  access_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ModuleTaintWrapper.TaintPoint.access_paths)
}
inline void ModuleTaintWrapper_TaintPoint::set_access_paths(int index, const char* value, size_t size) {
  access_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ModuleTaintWrapper.TaintPoint.access_paths)
}
inline ::std::string* ModuleTaintWrapper_TaintPoint::add_access_paths() {
  // @@protoc_insertion_point(field_add_mutable:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  return access_paths_.Add();
}
inline void ModuleTaintWrapper_TaintPoint::add_access_paths(const ::std::string& value) {
  access_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.ModuleTaintWrapper.TaintPoint.access_paths)
}
#if LANG_CXX11
inline void ModuleTaintWrapper_TaintPoint::add_access_paths(::std::string&& value) {
  access_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.ModuleTaintWrapper.TaintPoint.access_paths)
}
#endif
inline void ModuleTaintWrapper_TaintPoint::add_access_paths(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  access_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.ModuleTaintWrapper.TaintPoint.access_paths)
}
inline void ModuleTaintWrapper_TaintPoint::add_access_paths(const char* value, size_t size) {
  access_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.ModuleTaintWrapper.TaintPoint.access_paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModuleTaintWrapper_TaintPoint::access_paths() const {
  // @@protoc_insertion_point(field_list:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  return access_paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModuleTaintWrapper_TaintPoint::mutable_access_paths() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleTaintWrapper.TaintPoint.access_paths)
  return &access_paths_;
}

// -------------------------------------------------------------------

// ModuleTaintWrapper_TaintRule

// .proto.ModuleTaintWrapper.TaintPoint cause = 1;
inline bool ModuleTaintWrapper_TaintRule::has_cause() const {
  return this != internal_default_instance() && cause_ != NULL;
}
inline void ModuleTaintWrapper_TaintRule::clear_cause() {
  if (GetArenaNoVirtual() == NULL && cause_ != NULL) {
    delete cause_;
  }
  cause_ = NULL;
}
inline const ::proto::ModuleTaintWrapper_TaintPoint& ModuleTaintWrapper_TaintRule::_internal_cause() const {
  return *cause_;
}
inline const ::proto::ModuleTaintWrapper_TaintPoint& ModuleTaintWrapper_TaintRule::cause() const {
  const ::proto::ModuleTaintWrapper_TaintPoint* p = cause_;
  // @@protoc_insertion_point(field_get:proto.ModuleTaintWrapper.TaintRule.cause)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::ModuleTaintWrapper_TaintPoint*>(
      &::proto::_ModuleTaintWrapper_TaintPoint_default_instance_);
}
inline ::proto::ModuleTaintWrapper_TaintPoint* ModuleTaintWrapper_TaintRule::release_cause() {
  // @@protoc_insertion_point(field_release:proto.ModuleTaintWrapper.TaintRule.cause)
  
  ::proto::ModuleTaintWrapper_TaintPoint* temp = cause_;
  cause_ = NULL;
  return temp;
}
inline ::proto::ModuleTaintWrapper_TaintPoint* ModuleTaintWrapper_TaintRule::mutable_cause() {
  
  if (cause_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ModuleTaintWrapper_TaintPoint>(GetArenaNoVirtual());
    cause_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleTaintWrapper.TaintRule.cause)
  return cause_;
}
inline void ModuleTaintWrapper_TaintRule::set_allocated_cause(::proto::ModuleTaintWrapper_TaintPoint* cause) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cause_;
  }
  if (cause) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cause = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cause, submessage_arena);
    }
    
  } else {
    
  }
  cause_ = cause;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleTaintWrapper.TaintRule.cause)
}

// repeated .proto.ModuleTaintWrapper.TaintPoint effects = 2;
inline int ModuleTaintWrapper_TaintRule::effects_size() const {
  return effects_.size();
}
inline void ModuleTaintWrapper_TaintRule::clear_effects() {
  effects_.Clear();
}
inline ::proto::ModuleTaintWrapper_TaintPoint* ModuleTaintWrapper_TaintRule::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleTaintWrapper.TaintRule.effects)
  return effects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintPoint >*
ModuleTaintWrapper_TaintRule::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleTaintWrapper.TaintRule.effects)
  return &effects_;
}
inline const ::proto::ModuleTaintWrapper_TaintPoint& ModuleTaintWrapper_TaintRule::effects(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleTaintWrapper.TaintRule.effects)
  return effects_.Get(index);
}
inline ::proto::ModuleTaintWrapper_TaintPoint* ModuleTaintWrapper_TaintRule::add_effects() {
  // @@protoc_insertion_point(field_add:proto.ModuleTaintWrapper.TaintRule.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintPoint >&
ModuleTaintWrapper_TaintRule::effects() const {
  // @@protoc_insertion_point(field_list:proto.ModuleTaintWrapper.TaintRule.effects)
  return effects_;
}

// -------------------------------------------------------------------

// ModuleTaintWrapper

// .proto.AstNode node = 1;
inline bool ModuleTaintWrapper::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline const ::proto::AstNode& ModuleTaintWrapper::_internal_node() const {
  return *node_;
}
inline const ::proto::AstNode& ModuleTaintWrapper::node() const {
  const ::proto::AstNode* p = node_;
  // @@protoc_insertion_point(field_get:proto.ModuleTaintWrapper.node)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstNode*>(
      &::proto::_AstNode_default_instance_);
}
inline ::proto::AstNode* ModuleTaintWrapper::release_node() {
  // @@protoc_insertion_point(field_release:proto.ModuleTaintWrapper.node)
  
  ::proto::AstNode* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::proto::AstNode* ModuleTaintWrapper::mutable_node() {
  
  if (node_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstNode>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleTaintWrapper.node)
  return node_;
}
inline void ModuleTaintWrapper::set_allocated_node(::proto::AstNode* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleTaintWrapper.node)
}

// repeated .proto.ModuleTaintWrapper.TaintRule rules = 2;
inline int ModuleTaintWrapper::rules_size() const {
  return rules_.size();
}
inline void ModuleTaintWrapper::clear_rules() {
  rules_.Clear();
}
inline ::proto::ModuleTaintWrapper_TaintRule* ModuleTaintWrapper::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleTaintWrapper.rules)
  return rules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintRule >*
ModuleTaintWrapper::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleTaintWrapper.rules)
  return &rules_;
}
inline const ::proto::ModuleTaintWrapper_TaintRule& ModuleTaintWrapper::rules(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleTaintWrapper.rules)
  return rules_.Get(index);
}
inline ::proto::ModuleTaintWrapper_TaintRule* ModuleTaintWrapper::add_rules() {
  // @@protoc_insertion_point(field_add:proto.ModuleTaintWrapper.rules)
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper_TaintRule >&
ModuleTaintWrapper::rules() const {
  // @@protoc_insertion_point(field_list:proto.ModuleTaintWrapper.rules)
  return rules_;
}

// -------------------------------------------------------------------

// ModuleFlow_FlowInfo

// string name = 1;
inline void ModuleFlow_FlowInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModuleFlow_FlowInfo::name() const {
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.FlowInfo.name)
  return name_.GetNoArena();
}
inline void ModuleFlow_FlowInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ModuleFlow.FlowInfo.name)
}
#if LANG_CXX11
inline void ModuleFlow_FlowInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ModuleFlow.FlowInfo.name)
}
#endif
inline void ModuleFlow_FlowInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ModuleFlow.FlowInfo.name)
}
inline void ModuleFlow_FlowInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ModuleFlow.FlowInfo.name)
}
inline ::std::string* ModuleFlow_FlowInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.FlowInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleFlow_FlowInfo::release_name() {
  // @@protoc_insertion_point(field_release:proto.ModuleFlow.FlowInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModuleFlow_FlowInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleFlow.FlowInfo.name)
}

// string cwe = 2;
inline void ModuleFlow_FlowInfo::clear_cwe() {
  cwe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModuleFlow_FlowInfo::cwe() const {
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.FlowInfo.cwe)
  return cwe_.GetNoArena();
}
inline void ModuleFlow_FlowInfo::set_cwe(const ::std::string& value) {
  
  cwe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ModuleFlow.FlowInfo.cwe)
}
#if LANG_CXX11
inline void ModuleFlow_FlowInfo::set_cwe(::std::string&& value) {
  
  cwe_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ModuleFlow.FlowInfo.cwe)
}
#endif
inline void ModuleFlow_FlowInfo::set_cwe(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cwe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ModuleFlow.FlowInfo.cwe)
}
inline void ModuleFlow_FlowInfo::set_cwe(const char* value, size_t size) {
  
  cwe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ModuleFlow.FlowInfo.cwe)
}
inline ::std::string* ModuleFlow_FlowInfo::mutable_cwe() {
  
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.FlowInfo.cwe)
  return cwe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleFlow_FlowInfo::release_cwe() {
  // @@protoc_insertion_point(field_release:proto.ModuleFlow.FlowInfo.cwe)
  
  return cwe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModuleFlow_FlowInfo::set_allocated_cwe(::std::string* cwe) {
  if (cwe != NULL) {
    
  } else {
    
  }
  cwe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cwe);
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleFlow.FlowInfo.cwe)
}

// string type = 3;
inline void ModuleFlow_FlowInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModuleFlow_FlowInfo::type() const {
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.FlowInfo.type)
  return type_.GetNoArena();
}
inline void ModuleFlow_FlowInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ModuleFlow.FlowInfo.type)
}
#if LANG_CXX11
inline void ModuleFlow_FlowInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ModuleFlow.FlowInfo.type)
}
#endif
inline void ModuleFlow_FlowInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ModuleFlow.FlowInfo.type)
}
inline void ModuleFlow_FlowInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ModuleFlow.FlowInfo.type)
}
inline ::std::string* ModuleFlow_FlowInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.FlowInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleFlow_FlowInfo::release_type() {
  // @@protoc_insertion_point(field_release:proto.ModuleFlow.FlowInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModuleFlow_FlowInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleFlow.FlowInfo.type)
}

// -------------------------------------------------------------------

// ModuleFlow

// .proto.AstNode source = 1;
inline bool ModuleFlow::has_source() const {
  return this != internal_default_instance() && source_ != NULL;
}
inline const ::proto::AstNode& ModuleFlow::_internal_source() const {
  return *source_;
}
inline const ::proto::AstNode& ModuleFlow::source() const {
  const ::proto::AstNode* p = source_;
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.source)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstNode*>(
      &::proto::_AstNode_default_instance_);
}
inline ::proto::AstNode* ModuleFlow::release_source() {
  // @@protoc_insertion_point(field_release:proto.ModuleFlow.source)
  
  ::proto::AstNode* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::proto::AstNode* ModuleFlow::mutable_source() {
  
  if (source_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstNode>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.source)
  return source_;
}
inline void ModuleFlow::set_allocated_source(::proto::AstNode* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(source_);
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleFlow.source)
}

// repeated .proto.AstNode hops = 2;
inline int ModuleFlow::hops_size() const {
  return hops_.size();
}
inline ::proto::AstNode* ModuleFlow::mutable_hops(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.hops)
  return hops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
ModuleFlow::mutable_hops() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleFlow.hops)
  return &hops_;
}
inline const ::proto::AstNode& ModuleFlow::hops(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.hops)
  return hops_.Get(index);
}
inline ::proto::AstNode* ModuleFlow::add_hops() {
  // @@protoc_insertion_point(field_add:proto.ModuleFlow.hops)
  return hops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
ModuleFlow::hops() const {
  // @@protoc_insertion_point(field_list:proto.ModuleFlow.hops)
  return hops_;
}

// .proto.AstNode sink = 3;
inline bool ModuleFlow::has_sink() const {
  return this != internal_default_instance() && sink_ != NULL;
}
inline const ::proto::AstNode& ModuleFlow::_internal_sink() const {
  return *sink_;
}
inline const ::proto::AstNode& ModuleFlow::sink() const {
  const ::proto::AstNode* p = sink_;
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.sink)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstNode*>(
      &::proto::_AstNode_default_instance_);
}
inline ::proto::AstNode* ModuleFlow::release_sink() {
  // @@protoc_insertion_point(field_release:proto.ModuleFlow.sink)
  
  ::proto::AstNode* temp = sink_;
  sink_ = NULL;
  return temp;
}
inline ::proto::AstNode* ModuleFlow::mutable_sink() {
  
  if (sink_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstNode>(GetArenaNoVirtual());
    sink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.sink)
  return sink_;
}
inline void ModuleFlow::set_allocated_sink(::proto::AstNode* sink) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sink_);
  }
  if (sink) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink, submessage_arena);
    }
    
  } else {
    
  }
  sink_ = sink;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleFlow.sink)
}

// .proto.ModuleFlow.FlowInfo info = 4;
inline bool ModuleFlow::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void ModuleFlow::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::proto::ModuleFlow_FlowInfo& ModuleFlow::_internal_info() const {
  return *info_;
}
inline const ::proto::ModuleFlow_FlowInfo& ModuleFlow::info() const {
  const ::proto::ModuleFlow_FlowInfo* p = info_;
  // @@protoc_insertion_point(field_get:proto.ModuleFlow.info)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::ModuleFlow_FlowInfo*>(
      &::proto::_ModuleFlow_FlowInfo_default_instance_);
}
inline ::proto::ModuleFlow_FlowInfo* ModuleFlow::release_info() {
  // @@protoc_insertion_point(field_release:proto.ModuleFlow.info)
  
  ::proto::ModuleFlow_FlowInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::proto::ModuleFlow_FlowInfo* ModuleFlow::mutable_info() {
  
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ModuleFlow_FlowInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleFlow.info)
  return info_;
}
inline void ModuleFlow::set_allocated_info(::proto::ModuleFlow_FlowInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleFlow.info)
}

// -------------------------------------------------------------------

// ModuleDanger

// .proto.AstNode danger = 1;
inline bool ModuleDanger::has_danger() const {
  return this != internal_default_instance() && danger_ != NULL;
}
inline const ::proto::AstNode& ModuleDanger::_internal_danger() const {
  return *danger_;
}
inline const ::proto::AstNode& ModuleDanger::danger() const {
  const ::proto::AstNode* p = danger_;
  // @@protoc_insertion_point(field_get:proto.ModuleDanger.danger)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstNode*>(
      &::proto::_AstNode_default_instance_);
}
inline ::proto::AstNode* ModuleDanger::release_danger() {
  // @@protoc_insertion_point(field_release:proto.ModuleDanger.danger)
  
  ::proto::AstNode* temp = danger_;
  danger_ = NULL;
  return temp;
}
inline ::proto::AstNode* ModuleDanger::mutable_danger() {
  
  if (danger_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstNode>(GetArenaNoVirtual());
    danger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleDanger.danger)
  return danger_;
}
inline void ModuleDanger::set_allocated_danger(::proto::AstNode* danger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(danger_);
  }
  if (danger) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      danger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, danger, submessage_arena);
    }
    
  } else {
    
  }
  danger_ = danger;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleDanger.danger)
}

// repeated .proto.AstNode slices = 2;
inline int ModuleDanger::slices_size() const {
  return slices_.size();
}
inline ::proto::AstNode* ModuleDanger::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleDanger.slices)
  return slices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
ModuleDanger::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleDanger.slices)
  return &slices_;
}
inline const ::proto::AstNode& ModuleDanger::slices(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleDanger.slices)
  return slices_.Get(index);
}
inline ::proto::AstNode* ModuleDanger::add_slices() {
  // @@protoc_insertion_point(field_add:proto.ModuleDanger.slices)
  return slices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
ModuleDanger::slices() const {
  // @@protoc_insertion_point(field_list:proto.ModuleDanger.slices)
  return slices_;
}

// -------------------------------------------------------------------

// ModuleSummary

// .proto.PackageInfo package_info = 1;
inline bool ModuleSummary::has_package_info() const {
  return this != internal_default_instance() && package_info_ != NULL;
}
inline const ::proto::PackageInfo& ModuleSummary::_internal_package_info() const {
  return *package_info_;
}
inline const ::proto::PackageInfo& ModuleSummary::package_info() const {
  const ::proto::PackageInfo* p = package_info_;
  // @@protoc_insertion_point(field_get:proto.ModuleSummary.package_info)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::PackageInfo*>(
      &::proto::_PackageInfo_default_instance_);
}
inline ::proto::PackageInfo* ModuleSummary::release_package_info() {
  // @@protoc_insertion_point(field_release:proto.ModuleSummary.package_info)
  
  ::proto::PackageInfo* temp = package_info_;
  package_info_ = NULL;
  return temp;
}
inline ::proto::PackageInfo* ModuleSummary::mutable_package_info() {
  
  if (package_info_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::PackageInfo>(GetArenaNoVirtual());
    package_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleSummary.package_info)
  return package_info_;
}
inline void ModuleSummary::set_allocated_package_info(::proto::PackageInfo* package_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(package_info_);
  }
  if (package_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      package_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, package_info, submessage_arena);
    }
    
  } else {
    
  }
  package_info_ = package_info;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleSummary.package_info)
}

// repeated .proto.ModuleSource sources = 2;
inline int ModuleSummary::sources_size() const {
  return sources_.size();
}
inline void ModuleSummary::clear_sources() {
  sources_.Clear();
}
inline ::proto::ModuleSource* ModuleSummary::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleSummary.sources)
  return sources_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >*
ModuleSummary::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleSummary.sources)
  return &sources_;
}
inline const ::proto::ModuleSource& ModuleSummary::sources(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleSummary.sources)
  return sources_.Get(index);
}
inline ::proto::ModuleSource* ModuleSummary::add_sources() {
  // @@protoc_insertion_point(field_add:proto.ModuleSummary.sources)
  return sources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >&
ModuleSummary::sources() const {
  // @@protoc_insertion_point(field_list:proto.ModuleSummary.sources)
  return sources_;
}

// repeated .proto.ModuleSink sinks = 3;
inline int ModuleSummary::sinks_size() const {
  return sinks_.size();
}
inline void ModuleSummary::clear_sinks() {
  sinks_.Clear();
}
inline ::proto::ModuleSink* ModuleSummary::mutable_sinks(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleSummary.sinks)
  return sinks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >*
ModuleSummary::mutable_sinks() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleSummary.sinks)
  return &sinks_;
}
inline const ::proto::ModuleSink& ModuleSummary::sinks(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleSummary.sinks)
  return sinks_.Get(index);
}
inline ::proto::ModuleSink* ModuleSummary::add_sinks() {
  // @@protoc_insertion_point(field_add:proto.ModuleSummary.sinks)
  return sinks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >&
ModuleSummary::sinks() const {
  // @@protoc_insertion_point(field_list:proto.ModuleSummary.sinks)
  return sinks_;
}

// repeated .proto.ModuleTaintWrapper taint_wrappers = 4;
inline int ModuleSummary::taint_wrappers_size() const {
  return taint_wrappers_.size();
}
inline void ModuleSummary::clear_taint_wrappers() {
  taint_wrappers_.Clear();
}
inline ::proto::ModuleTaintWrapper* ModuleSummary::mutable_taint_wrappers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleSummary.taint_wrappers)
  return taint_wrappers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >*
ModuleSummary::mutable_taint_wrappers() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleSummary.taint_wrappers)
  return &taint_wrappers_;
}
inline const ::proto::ModuleTaintWrapper& ModuleSummary::taint_wrappers(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleSummary.taint_wrappers)
  return taint_wrappers_.Get(index);
}
inline ::proto::ModuleTaintWrapper* ModuleSummary::add_taint_wrappers() {
  // @@protoc_insertion_point(field_add:proto.ModuleSummary.taint_wrappers)
  return taint_wrappers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >&
ModuleSummary::taint_wrappers() const {
  // @@protoc_insertion_point(field_list:proto.ModuleSummary.taint_wrappers)
  return taint_wrappers_;
}

// -------------------------------------------------------------------

// ModuleResult

// .proto.PackageInfo package_info = 1;
inline bool ModuleResult::has_package_info() const {
  return this != internal_default_instance() && package_info_ != NULL;
}
inline const ::proto::PackageInfo& ModuleResult::_internal_package_info() const {
  return *package_info_;
}
inline const ::proto::PackageInfo& ModuleResult::package_info() const {
  const ::proto::PackageInfo* p = package_info_;
  // @@protoc_insertion_point(field_get:proto.ModuleResult.package_info)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::PackageInfo*>(
      &::proto::_PackageInfo_default_instance_);
}
inline ::proto::PackageInfo* ModuleResult::release_package_info() {
  // @@protoc_insertion_point(field_release:proto.ModuleResult.package_info)
  
  ::proto::PackageInfo* temp = package_info_;
  package_info_ = NULL;
  return temp;
}
inline ::proto::PackageInfo* ModuleResult::mutable_package_info() {
  
  if (package_info_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::PackageInfo>(GetArenaNoVirtual());
    package_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleResult.package_info)
  return package_info_;
}
inline void ModuleResult::set_allocated_package_info(::proto::PackageInfo* package_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(package_info_);
  }
  if (package_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      package_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, package_info, submessage_arena);
    }
    
  } else {
    
  }
  package_info_ = package_info;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleResult.package_info)
}

// repeated .proto.ModuleFlow flows = 2;
inline int ModuleResult::flows_size() const {
  return flows_.size();
}
inline void ModuleResult::clear_flows() {
  flows_.Clear();
}
inline ::proto::ModuleFlow* ModuleResult::mutable_flows(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleResult.flows)
  return flows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >*
ModuleResult::mutable_flows() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleResult.flows)
  return &flows_;
}
inline const ::proto::ModuleFlow& ModuleResult::flows(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleResult.flows)
  return flows_.Get(index);
}
inline ::proto::ModuleFlow* ModuleResult::add_flows() {
  // @@protoc_insertion_point(field_add:proto.ModuleResult.flows)
  return flows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >&
ModuleResult::flows() const {
  // @@protoc_insertion_point(field_list:proto.ModuleResult.flows)
  return flows_;
}

// repeated .proto.ModuleDanger dangers = 3;
inline int ModuleResult::dangers_size() const {
  return dangers_.size();
}
inline void ModuleResult::clear_dangers() {
  dangers_.Clear();
}
inline ::proto::ModuleDanger* ModuleResult::mutable_dangers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleResult.dangers)
  return dangers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >*
ModuleResult::mutable_dangers() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleResult.dangers)
  return &dangers_;
}
inline const ::proto::ModuleDanger& ModuleResult::dangers(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleResult.dangers)
  return dangers_.Get(index);
}
inline ::proto::ModuleDanger* ModuleResult::add_dangers() {
  // @@protoc_insertion_point(field_add:proto.ModuleResult.dangers)
  return dangers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >&
ModuleResult::dangers() const {
  // @@protoc_insertion_point(field_list:proto.ModuleResult.dangers)
  return dangers_;
}

// -------------------------------------------------------------------

// ModuleStatic

// .proto.PackageInfo package_info = 1;
inline bool ModuleStatic::has_package_info() const {
  return this != internal_default_instance() && package_info_ != NULL;
}
inline const ::proto::PackageInfo& ModuleStatic::_internal_package_info() const {
  return *package_info_;
}
inline const ::proto::PackageInfo& ModuleStatic::package_info() const {
  const ::proto::PackageInfo* p = package_info_;
  // @@protoc_insertion_point(field_get:proto.ModuleStatic.package_info)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::PackageInfo*>(
      &::proto::_PackageInfo_default_instance_);
}
inline ::proto::PackageInfo* ModuleStatic::release_package_info() {
  // @@protoc_insertion_point(field_release:proto.ModuleStatic.package_info)
  
  ::proto::PackageInfo* temp = package_info_;
  package_info_ = NULL;
  return temp;
}
inline ::proto::PackageInfo* ModuleStatic::mutable_package_info() {
  
  if (package_info_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::PackageInfo>(GetArenaNoVirtual());
    package_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ModuleStatic.package_info)
  return package_info_;
}
inline void ModuleStatic::set_allocated_package_info(::proto::PackageInfo* package_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(package_info_);
  }
  if (package_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      package_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, package_info, submessage_arena);
    }
    
  } else {
    
  }
  package_info_ = package_info;
  // @@protoc_insertion_point(field_set_allocated:proto.ModuleStatic.package_info)
}

// repeated .proto.ModuleFlow flows = 2;
inline int ModuleStatic::flows_size() const {
  return flows_.size();
}
inline void ModuleStatic::clear_flows() {
  flows_.Clear();
}
inline ::proto::ModuleFlow* ModuleStatic::mutable_flows(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleStatic.flows)
  return flows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >*
ModuleStatic::mutable_flows() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleStatic.flows)
  return &flows_;
}
inline const ::proto::ModuleFlow& ModuleStatic::flows(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleStatic.flows)
  return flows_.Get(index);
}
inline ::proto::ModuleFlow* ModuleStatic::add_flows() {
  // @@protoc_insertion_point(field_add:proto.ModuleStatic.flows)
  return flows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleFlow >&
ModuleStatic::flows() const {
  // @@protoc_insertion_point(field_list:proto.ModuleStatic.flows)
  return flows_;
}

// repeated .proto.ModuleDanger dangers = 3;
inline int ModuleStatic::dangers_size() const {
  return dangers_.size();
}
inline void ModuleStatic::clear_dangers() {
  dangers_.Clear();
}
inline ::proto::ModuleDanger* ModuleStatic::mutable_dangers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleStatic.dangers)
  return dangers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >*
ModuleStatic::mutable_dangers() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleStatic.dangers)
  return &dangers_;
}
inline const ::proto::ModuleDanger& ModuleStatic::dangers(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleStatic.dangers)
  return dangers_.Get(index);
}
inline ::proto::ModuleDanger* ModuleStatic::add_dangers() {
  // @@protoc_insertion_point(field_add:proto.ModuleStatic.dangers)
  return dangers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleDanger >&
ModuleStatic::dangers() const {
  // @@protoc_insertion_point(field_list:proto.ModuleStatic.dangers)
  return dangers_;
}

// repeated .proto.ModuleSource sources = 4;
inline int ModuleStatic::sources_size() const {
  return sources_.size();
}
inline void ModuleStatic::clear_sources() {
  sources_.Clear();
}
inline ::proto::ModuleSource* ModuleStatic::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleStatic.sources)
  return sources_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >*
ModuleStatic::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleStatic.sources)
  return &sources_;
}
inline const ::proto::ModuleSource& ModuleStatic::sources(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleStatic.sources)
  return sources_.Get(index);
}
inline ::proto::ModuleSource* ModuleStatic::add_sources() {
  // @@protoc_insertion_point(field_add:proto.ModuleStatic.sources)
  return sources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSource >&
ModuleStatic::sources() const {
  // @@protoc_insertion_point(field_list:proto.ModuleStatic.sources)
  return sources_;
}

// repeated .proto.ModuleSink sinks = 5;
inline int ModuleStatic::sinks_size() const {
  return sinks_.size();
}
inline void ModuleStatic::clear_sinks() {
  sinks_.Clear();
}
inline ::proto::ModuleSink* ModuleStatic::mutable_sinks(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleStatic.sinks)
  return sinks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >*
ModuleStatic::mutable_sinks() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleStatic.sinks)
  return &sinks_;
}
inline const ::proto::ModuleSink& ModuleStatic::sinks(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleStatic.sinks)
  return sinks_.Get(index);
}
inline ::proto::ModuleSink* ModuleStatic::add_sinks() {
  // @@protoc_insertion_point(field_add:proto.ModuleStatic.sinks)
  return sinks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleSink >&
ModuleStatic::sinks() const {
  // @@protoc_insertion_point(field_list:proto.ModuleStatic.sinks)
  return sinks_;
}

// repeated .proto.ModuleTaintWrapper taint_wrappers = 6;
inline int ModuleStatic::taint_wrappers_size() const {
  return taint_wrappers_.size();
}
inline void ModuleStatic::clear_taint_wrappers() {
  taint_wrappers_.Clear();
}
inline ::proto::ModuleTaintWrapper* ModuleStatic::mutable_taint_wrappers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ModuleStatic.taint_wrappers)
  return taint_wrappers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >*
ModuleStatic::mutable_taint_wrappers() {
  // @@protoc_insertion_point(field_mutable_list:proto.ModuleStatic.taint_wrappers)
  return &taint_wrappers_;
}
inline const ::proto::ModuleTaintWrapper& ModuleStatic::taint_wrappers(int index) const {
  // @@protoc_insertion_point(field_get:proto.ModuleStatic.taint_wrappers)
  return taint_wrappers_.Get(index);
}
inline ::proto::ModuleTaintWrapper* ModuleStatic::add_taint_wrappers() {
  // @@protoc_insertion_point(field_add:proto.ModuleStatic.taint_wrappers)
  return taint_wrappers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ModuleTaintWrapper >&
ModuleStatic::taint_wrappers() const {
  // @@protoc_insertion_point(field_list:proto.ModuleStatic.taint_wrappers)
  return taint_wrappers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_module_2eproto
