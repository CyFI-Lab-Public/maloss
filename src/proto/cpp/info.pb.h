// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: info.proto

#ifndef PROTOBUF_INCLUDED_info_2eproto
#define PROTOBUF_INCLUDED_info_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_info_2eproto 

namespace protobuf_info_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_info_2eproto
namespace proto {
class ExecuteInfo;
class ExecuteInfoDefaultTypeInternal;
extern ExecuteInfoDefaultTypeInternal _ExecuteInfo_default_instance_;
class PackageInfo;
class PackageInfoDefaultTypeInternal;
extern PackageInfoDefaultTypeInternal _PackageInfo_default_instance_;
class PackageInfo_Metadata;
class PackageInfo_MetadataDefaultTypeInternal;
extern PackageInfo_MetadataDefaultTypeInternal _PackageInfo_Metadata_default_instance_;
class ReleaseInfo;
class ReleaseInfoDefaultTypeInternal;
extern ReleaseInfoDefaultTypeInternal _ReleaseInfo_default_instance_;
class RepositoryInfo;
class RepositoryInfoDefaultTypeInternal;
extern RepositoryInfoDefaultTypeInternal _RepositoryInfo_default_instance_;
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::ExecuteInfo* Arena::CreateMaybeMessage<::proto::ExecuteInfo>(Arena*);
template<> ::proto::PackageInfo* Arena::CreateMaybeMessage<::proto::PackageInfo>(Arena*);
template<> ::proto::PackageInfo_Metadata* Arena::CreateMaybeMessage<::proto::PackageInfo_Metadata>(Arena*);
template<> ::proto::ReleaseInfo* Arena::CreateMaybeMessage<::proto::ReleaseInfo>(Arena*);
template<> ::proto::RepositoryInfo* Arena::CreateMaybeMessage<::proto::RepositoryInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {

// ===================================================================

class ReleaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ReleaseInfo) */ {
 public:
  ReleaseInfo();
  virtual ~ReleaseInfo();

  ReleaseInfo(const ReleaseInfo& from);

  inline ReleaseInfo& operator=(const ReleaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseInfo(ReleaseInfo&& from) noexcept
    : ReleaseInfo() {
    *this = ::std::move(from);
  }

  inline ReleaseInfo& operator=(ReleaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseInfo* internal_default_instance() {
    return reinterpret_cast<const ReleaseInfo*>(
               &_ReleaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ReleaseInfo* other);
  friend void swap(ReleaseInfo& a, ReleaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseInfo* New() const final {
    return CreateMaybeMessage<ReleaseInfo>(NULL);
  }

  ReleaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReleaseInfo& from);
  void MergeFrom(const ReleaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::std::string& timestamp() const;
  void set_timestamp(const ::std::string& value);
  #if LANG_CXX11
  void set_timestamp(::std::string&& value);
  #endif
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  ::std::string* mutable_timestamp();
  ::std::string* release_timestamp();
  void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:proto.ReleaseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_info_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepositoryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.RepositoryInfo) */ {
 public:
  RepositoryInfo();
  virtual ~RepositoryInfo();

  RepositoryInfo(const RepositoryInfo& from);

  inline RepositoryInfo& operator=(const RepositoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepositoryInfo(RepositoryInfo&& from) noexcept
    : RepositoryInfo() {
    *this = ::std::move(from);
  }

  inline RepositoryInfo& operator=(RepositoryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RepositoryInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepositoryInfo* internal_default_instance() {
    return reinterpret_cast<const RepositoryInfo*>(
               &_RepositoryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RepositoryInfo* other);
  friend void swap(RepositoryInfo& a, RepositoryInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepositoryInfo* New() const final {
    return CreateMaybeMessage<RepositoryInfo>(NULL);
  }

  RepositoryInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepositoryInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepositoryInfo& from);
  void MergeFrom(const RepositoryInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositoryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:proto.RepositoryInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_info_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ExecuteInfo) */ {
 public:
  ExecuteInfo();
  virtual ~ExecuteInfo();

  ExecuteInfo(const ExecuteInfo& from);

  inline ExecuteInfo& operator=(const ExecuteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteInfo(ExecuteInfo&& from) noexcept
    : ExecuteInfo() {
    *this = ::std::move(from);
  }

  inline ExecuteInfo& operator=(ExecuteInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteInfo* internal_default_instance() {
    return reinterpret_cast<const ExecuteInfo*>(
               &_ExecuteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ExecuteInfo* other);
  friend void swap(ExecuteInfo& a, ExecuteInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteInfo* New() const final {
    return CreateMaybeMessage<ExecuteInfo>(NULL);
  }

  ExecuteInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteInfo& from);
  void MergeFrom(const ExecuteInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // string command = 2;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:proto.ExecuteInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_info_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PackageInfo_Metadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.PackageInfo.Metadata) */ {
 public:
  PackageInfo_Metadata();
  virtual ~PackageInfo_Metadata();

  PackageInfo_Metadata(const PackageInfo_Metadata& from);

  inline PackageInfo_Metadata& operator=(const PackageInfo_Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PackageInfo_Metadata(PackageInfo_Metadata&& from) noexcept
    : PackageInfo_Metadata() {
    *this = ::std::move(from);
  }

  inline PackageInfo_Metadata& operator=(PackageInfo_Metadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PackageInfo_Metadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PackageInfo_Metadata* internal_default_instance() {
    return reinterpret_cast<const PackageInfo_Metadata*>(
               &_PackageInfo_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PackageInfo_Metadata* other);
  friend void swap(PackageInfo_Metadata& a, PackageInfo_Metadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PackageInfo_Metadata* New() const final {
    return CreateMaybeMessage<PackageInfo_Metadata>(NULL);
  }

  PackageInfo_Metadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PackageInfo_Metadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PackageInfo_Metadata& from);
  void MergeFrom(const PackageInfo_Metadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageInfo_Metadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.ExecuteInfo exec_jobs = 7;
  int exec_jobs_size() const;
  void clear_exec_jobs();
  static const int kExecJobsFieldNumber = 7;
  ::proto::ExecuteInfo* mutable_exec_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ExecuteInfo >*
      mutable_exec_jobs();
  const ::proto::ExecuteInfo& exec_jobs(int index) const;
  ::proto::ExecuteInfo* add_exec_jobs();
  const ::google::protobuf::RepeatedPtrField< ::proto::ExecuteInfo >&
      exec_jobs() const;

  // repeated string authors = 8;
  int authors_size() const;
  void clear_authors();
  static const int kAuthorsFieldNumber = 8;
  const ::std::string& authors(int index) const;
  ::std::string* mutable_authors(int index);
  void set_authors(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_authors(int index, ::std::string&& value);
  #endif
  void set_authors(int index, const char* value);
  void set_authors(int index, const char* value, size_t size);
  ::std::string* add_authors();
  void add_authors(const ::std::string& value);
  #if LANG_CXX11
  void add_authors(::std::string&& value);
  #endif
  void add_authors(const char* value);
  void add_authors(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& authors() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_authors();

  // repeated string contributors = 9;
  int contributors_size() const;
  void clear_contributors();
  static const int kContributorsFieldNumber = 9;
  const ::std::string& contributors(int index) const;
  ::std::string* mutable_contributors(int index);
  void set_contributors(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_contributors(int index, ::std::string&& value);
  #endif
  void set_contributors(int index, const char* value);
  void set_contributors(int index, const char* value, size_t size);
  ::std::string* add_contributors();
  void add_contributors(const ::std::string& value);
  #if LANG_CXX11
  void add_contributors(::std::string&& value);
  #endif
  void add_contributors(const char* value);
  void add_contributors(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& contributors() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_contributors();

  // repeated string maintainers = 10;
  int maintainers_size() const;
  void clear_maintainers();
  static const int kMaintainersFieldNumber = 10;
  const ::std::string& maintainers(int index) const;
  ::std::string* mutable_maintainers(int index);
  void set_maintainers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_maintainers(int index, ::std::string&& value);
  #endif
  void set_maintainers(int index, const char* value);
  void set_maintainers(int index, const char* value, size_t size);
  ::std::string* add_maintainers();
  void add_maintainers(const ::std::string& value);
  #if LANG_CXX11
  void add_maintainers(::std::string&& value);
  #endif
  void add_maintainers(const char* value);
  void add_maintainers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& maintainers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_maintainers();

  // repeated .proto.ReleaseInfo releases = 11;
  int releases_size() const;
  void clear_releases();
  static const int kReleasesFieldNumber = 11;
  ::proto::ReleaseInfo* mutable_releases(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::ReleaseInfo >*
      mutable_releases();
  const ::proto::ReleaseInfo& releases(int index) const;
  ::proto::ReleaseInfo* add_releases();
  const ::google::protobuf::RepeatedPtrField< ::proto::ReleaseInfo >&
      releases() const;

  // string package_name = 1;
  void clear_package_name();
  static const int kPackageNameFieldNumber = 1;
  const ::std::string& package_name() const;
  void set_package_name(const ::std::string& value);
  #if LANG_CXX11
  void set_package_name(::std::string&& value);
  #endif
  void set_package_name(const char* value);
  void set_package_name(const char* value, size_t size);
  ::std::string* mutable_package_name();
  ::std::string* release_package_name();
  void set_allocated_package_name(::std::string* package_name);

  // string package_version = 2;
  void clear_package_version();
  static const int kPackageVersionFieldNumber = 2;
  const ::std::string& package_version() const;
  void set_package_version(const ::std::string& value);
  #if LANG_CXX11
  void set_package_version(::std::string&& value);
  #endif
  void set_package_version(const char* value);
  void set_package_version(const char* value, size_t size);
  ::std::string* mutable_package_version();
  ::std::string* release_package_version();
  void set_allocated_package_version(::std::string* package_version);

  // string email = 3;
  void clear_email();
  static const int kEmailFieldNumber = 3;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string homepage = 4;
  void clear_homepage();
  static const int kHomepageFieldNumber = 4;
  const ::std::string& homepage() const;
  void set_homepage(const ::std::string& value);
  #if LANG_CXX11
  void set_homepage(::std::string&& value);
  #endif
  void set_homepage(const char* value);
  void set_homepage(const char* value, size_t size);
  ::std::string* mutable_homepage();
  ::std::string* release_homepage();
  void set_allocated_homepage(::std::string* homepage);

  // string license = 5;
  void clear_license();
  static const int kLicenseFieldNumber = 5;
  const ::std::string& license() const;
  void set_license(const ::std::string& value);
  #if LANG_CXX11
  void set_license(::std::string&& value);
  #endif
  void set_license(const char* value);
  void set_license(const char* value, size_t size);
  ::std::string* mutable_license();
  ::std::string* release_license();
  void set_allocated_license(::std::string* license);

  // .proto.RepositoryInfo repository = 6;
  bool has_repository() const;
  void clear_repository();
  static const int kRepositoryFieldNumber = 6;
  private:
  const ::proto::RepositoryInfo& _internal_repository() const;
  public:
  const ::proto::RepositoryInfo& repository() const;
  ::proto::RepositoryInfo* release_repository();
  ::proto::RepositoryInfo* mutable_repository();
  void set_allocated_repository(::proto::RepositoryInfo* repository);

  // @@protoc_insertion_point(class_scope:proto.PackageInfo.Metadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::ExecuteInfo > exec_jobs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> authors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> contributors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> maintainers_;
  ::google::protobuf::RepeatedPtrField< ::proto::ReleaseInfo > releases_;
  ::google::protobuf::internal::ArenaStringPtr package_name_;
  ::google::protobuf::internal::ArenaStringPtr package_version_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr homepage_;
  ::google::protobuf::internal::ArenaStringPtr license_;
  ::proto::RepositoryInfo* repository_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_info_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PackageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.PackageInfo) */ {
 public:
  PackageInfo();
  virtual ~PackageInfo();

  PackageInfo(const PackageInfo& from);

  inline PackageInfo& operator=(const PackageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PackageInfo(PackageInfo&& from) noexcept
    : PackageInfo() {
    *this = ::std::move(from);
  }

  inline PackageInfo& operator=(PackageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PackageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PackageInfo* internal_default_instance() {
    return reinterpret_cast<const PackageInfo*>(
               &_PackageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PackageInfo* other);
  friend void swap(PackageInfo& a, PackageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PackageInfo* New() const final {
    return CreateMaybeMessage<PackageInfo>(NULL);
  }

  PackageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PackageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PackageInfo& from);
  void MergeFrom(const PackageInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PackageInfo_Metadata Metadata;

  // accessors -------------------------------------------------------

  // repeated .proto.PackageInfo.Metadata dependencies = 2;
  int dependencies_size() const;
  void clear_dependencies();
  static const int kDependenciesFieldNumber = 2;
  ::proto::PackageInfo_Metadata* mutable_dependencies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >*
      mutable_dependencies();
  const ::proto::PackageInfo_Metadata& dependencies(int index) const;
  ::proto::PackageInfo_Metadata* add_dependencies();
  const ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >&
      dependencies() const;

  // repeated .proto.PackageInfo.Metadata dev_dependencies = 3;
  int dev_dependencies_size() const;
  void clear_dev_dependencies();
  static const int kDevDependenciesFieldNumber = 3;
  ::proto::PackageInfo_Metadata* mutable_dev_dependencies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >*
      mutable_dev_dependencies();
  const ::proto::PackageInfo_Metadata& dev_dependencies(int index) const;
  ::proto::PackageInfo_Metadata* add_dev_dependencies();
  const ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >&
      dev_dependencies() const;

  // .proto.PackageInfo.Metadata info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  private:
  const ::proto::PackageInfo_Metadata& _internal_info() const;
  public:
  const ::proto::PackageInfo_Metadata& info() const;
  ::proto::PackageInfo_Metadata* release_info();
  ::proto::PackageInfo_Metadata* mutable_info();
  void set_allocated_info(::proto::PackageInfo_Metadata* info);

  // @@protoc_insertion_point(class_scope:proto.PackageInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata > dependencies_;
  ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata > dev_dependencies_;
  ::proto::PackageInfo_Metadata* info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_info_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReleaseInfo

// string name = 1;
inline void ReleaseInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReleaseInfo::name() const {
  // @@protoc_insertion_point(field_get:proto.ReleaseInfo.name)
  return name_.GetNoArena();
}
inline void ReleaseInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ReleaseInfo.name)
}
#if LANG_CXX11
inline void ReleaseInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ReleaseInfo.name)
}
#endif
inline void ReleaseInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ReleaseInfo.name)
}
inline void ReleaseInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ReleaseInfo.name)
}
inline ::std::string* ReleaseInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.ReleaseInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReleaseInfo::release_name() {
  // @@protoc_insertion_point(field_release:proto.ReleaseInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReleaseInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.ReleaseInfo.name)
}

// string timestamp = 2;
inline void ReleaseInfo::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReleaseInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.ReleaseInfo.timestamp)
  return timestamp_.GetNoArena();
}
inline void ReleaseInfo::set_timestamp(const ::std::string& value) {
  
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ReleaseInfo.timestamp)
}
#if LANG_CXX11
inline void ReleaseInfo::set_timestamp(::std::string&& value) {
  
  timestamp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ReleaseInfo.timestamp)
}
#endif
inline void ReleaseInfo::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ReleaseInfo.timestamp)
}
inline void ReleaseInfo::set_timestamp(const char* value, size_t size) {
  
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ReleaseInfo.timestamp)
}
inline ::std::string* ReleaseInfo::mutable_timestamp() {
  
  // @@protoc_insertion_point(field_mutable:proto.ReleaseInfo.timestamp)
  return timestamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReleaseInfo::release_timestamp() {
  // @@protoc_insertion_point(field_release:proto.ReleaseInfo.timestamp)
  
  return timestamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReleaseInfo::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp != NULL) {
    
  } else {
    
  }
  timestamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:proto.ReleaseInfo.timestamp)
}

// -------------------------------------------------------------------

// RepositoryInfo

// string url = 1;
inline void RepositoryInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RepositoryInfo::url() const {
  // @@protoc_insertion_point(field_get:proto.RepositoryInfo.url)
  return url_.GetNoArena();
}
inline void RepositoryInfo::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.RepositoryInfo.url)
}
#if LANG_CXX11
inline void RepositoryInfo::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.RepositoryInfo.url)
}
#endif
inline void RepositoryInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.RepositoryInfo.url)
}
inline void RepositoryInfo::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.RepositoryInfo.url)
}
inline ::std::string* RepositoryInfo::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:proto.RepositoryInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RepositoryInfo::release_url() {
  // @@protoc_insertion_point(field_release:proto.RepositoryInfo.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RepositoryInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:proto.RepositoryInfo.url)
}

// string type = 2;
inline void RepositoryInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RepositoryInfo::type() const {
  // @@protoc_insertion_point(field_get:proto.RepositoryInfo.type)
  return type_.GetNoArena();
}
inline void RepositoryInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.RepositoryInfo.type)
}
#if LANG_CXX11
inline void RepositoryInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.RepositoryInfo.type)
}
#endif
inline void RepositoryInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.RepositoryInfo.type)
}
inline void RepositoryInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.RepositoryInfo.type)
}
inline ::std::string* RepositoryInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:proto.RepositoryInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RepositoryInfo::release_type() {
  // @@protoc_insertion_point(field_release:proto.RepositoryInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RepositoryInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:proto.RepositoryInfo.type)
}

// -------------------------------------------------------------------

// ExecuteInfo

// string target = 1;
inline void ExecuteInfo::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecuteInfo::target() const {
  // @@protoc_insertion_point(field_get:proto.ExecuteInfo.target)
  return target_.GetNoArena();
}
inline void ExecuteInfo::set_target(const ::std::string& value) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ExecuteInfo.target)
}
#if LANG_CXX11
inline void ExecuteInfo::set_target(::std::string&& value) {
  
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ExecuteInfo.target)
}
#endif
inline void ExecuteInfo::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ExecuteInfo.target)
}
inline void ExecuteInfo::set_target(const char* value, size_t size) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ExecuteInfo.target)
}
inline ::std::string* ExecuteInfo::mutable_target() {
  
  // @@protoc_insertion_point(field_mutable:proto.ExecuteInfo.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecuteInfo::release_target() {
  // @@protoc_insertion_point(field_release:proto.ExecuteInfo.target)
  
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecuteInfo::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    
  } else {
    
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:proto.ExecuteInfo.target)
}

// string command = 2;
inline void ExecuteInfo::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecuteInfo::command() const {
  // @@protoc_insertion_point(field_get:proto.ExecuteInfo.command)
  return command_.GetNoArena();
}
inline void ExecuteInfo::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ExecuteInfo.command)
}
#if LANG_CXX11
inline void ExecuteInfo::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ExecuteInfo.command)
}
#endif
inline void ExecuteInfo::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ExecuteInfo.command)
}
inline void ExecuteInfo::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ExecuteInfo.command)
}
inline ::std::string* ExecuteInfo::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:proto.ExecuteInfo.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecuteInfo::release_command() {
  // @@protoc_insertion_point(field_release:proto.ExecuteInfo.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecuteInfo::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:proto.ExecuteInfo.command)
}

// -------------------------------------------------------------------

// PackageInfo_Metadata

// string package_name = 1;
inline void PackageInfo_Metadata::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo_Metadata::package_name() const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.package_name)
  return package_name_.GetNoArena();
}
inline void PackageInfo_Metadata::set_package_name(const ::std::string& value) {
  
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.package_name)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_package_name(::std::string&& value) {
  
  package_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PackageInfo.Metadata.package_name)
}
#endif
inline void PackageInfo_Metadata::set_package_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.package_name)
}
inline void PackageInfo_Metadata::set_package_name(const char* value, size_t size) {
  
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.package_name)
}
inline ::std::string* PackageInfo_Metadata::mutable_package_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.package_name)
  return package_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo_Metadata::release_package_name() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.Metadata.package_name)
  
  return package_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo_Metadata::set_allocated_package_name(::std::string* package_name) {
  if (package_name != NULL) {
    
  } else {
    
  }
  package_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.Metadata.package_name)
}

// string package_version = 2;
inline void PackageInfo_Metadata::clear_package_version() {
  package_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo_Metadata::package_version() const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.package_version)
  return package_version_.GetNoArena();
}
inline void PackageInfo_Metadata::set_package_version(const ::std::string& value) {
  
  package_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.package_version)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_package_version(::std::string&& value) {
  
  package_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PackageInfo.Metadata.package_version)
}
#endif
inline void PackageInfo_Metadata::set_package_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.package_version)
}
inline void PackageInfo_Metadata::set_package_version(const char* value, size_t size) {
  
  package_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.package_version)
}
inline ::std::string* PackageInfo_Metadata::mutable_package_version() {
  
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.package_version)
  return package_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo_Metadata::release_package_version() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.Metadata.package_version)
  
  return package_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo_Metadata::set_allocated_package_version(::std::string* package_version) {
  if (package_version != NULL) {
    
  } else {
    
  }
  package_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_version);
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.Metadata.package_version)
}

// string email = 3;
inline void PackageInfo_Metadata::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo_Metadata::email() const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.email)
  return email_.GetNoArena();
}
inline void PackageInfo_Metadata::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.email)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PackageInfo.Metadata.email)
}
#endif
inline void PackageInfo_Metadata::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.email)
}
inline void PackageInfo_Metadata::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.email)
}
inline ::std::string* PackageInfo_Metadata::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo_Metadata::release_email() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.Metadata.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo_Metadata::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.Metadata.email)
}

// string homepage = 4;
inline void PackageInfo_Metadata::clear_homepage() {
  homepage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo_Metadata::homepage() const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.homepage)
  return homepage_.GetNoArena();
}
inline void PackageInfo_Metadata::set_homepage(const ::std::string& value) {
  
  homepage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.homepage)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_homepage(::std::string&& value) {
  
  homepage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PackageInfo.Metadata.homepage)
}
#endif
inline void PackageInfo_Metadata::set_homepage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  homepage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.homepage)
}
inline void PackageInfo_Metadata::set_homepage(const char* value, size_t size) {
  
  homepage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.homepage)
}
inline ::std::string* PackageInfo_Metadata::mutable_homepage() {
  
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.homepage)
  return homepage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo_Metadata::release_homepage() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.Metadata.homepage)
  
  return homepage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo_Metadata::set_allocated_homepage(::std::string* homepage) {
  if (homepage != NULL) {
    
  } else {
    
  }
  homepage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), homepage);
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.Metadata.homepage)
}

// string license = 5;
inline void PackageInfo_Metadata::clear_license() {
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo_Metadata::license() const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.license)
  return license_.GetNoArena();
}
inline void PackageInfo_Metadata::set_license(const ::std::string& value) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.license)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_license(::std::string&& value) {
  
  license_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PackageInfo.Metadata.license)
}
#endif
inline void PackageInfo_Metadata::set_license(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.license)
}
inline void PackageInfo_Metadata::set_license(const char* value, size_t size) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.license)
}
inline ::std::string* PackageInfo_Metadata::mutable_license() {
  
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.license)
  return license_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo_Metadata::release_license() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.Metadata.license)
  
  return license_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo_Metadata::set_allocated_license(::std::string* license) {
  if (license != NULL) {
    
  } else {
    
  }
  license_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license);
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.Metadata.license)
}

// .proto.RepositoryInfo repository = 6;
inline bool PackageInfo_Metadata::has_repository() const {
  return this != internal_default_instance() && repository_ != NULL;
}
inline void PackageInfo_Metadata::clear_repository() {
  if (GetArenaNoVirtual() == NULL && repository_ != NULL) {
    delete repository_;
  }
  repository_ = NULL;
}
inline const ::proto::RepositoryInfo& PackageInfo_Metadata::_internal_repository() const {
  return *repository_;
}
inline const ::proto::RepositoryInfo& PackageInfo_Metadata::repository() const {
  const ::proto::RepositoryInfo* p = repository_;
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.repository)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::RepositoryInfo*>(
      &::proto::_RepositoryInfo_default_instance_);
}
inline ::proto::RepositoryInfo* PackageInfo_Metadata::release_repository() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.Metadata.repository)
  
  ::proto::RepositoryInfo* temp = repository_;
  repository_ = NULL;
  return temp;
}
inline ::proto::RepositoryInfo* PackageInfo_Metadata::mutable_repository() {
  
  if (repository_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::RepositoryInfo>(GetArenaNoVirtual());
    repository_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.repository)
  return repository_;
}
inline void PackageInfo_Metadata::set_allocated_repository(::proto::RepositoryInfo* repository) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete repository_;
  }
  if (repository) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      repository = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.Metadata.repository)
}

// repeated .proto.ExecuteInfo exec_jobs = 7;
inline int PackageInfo_Metadata::exec_jobs_size() const {
  return exec_jobs_.size();
}
inline void PackageInfo_Metadata::clear_exec_jobs() {
  exec_jobs_.Clear();
}
inline ::proto::ExecuteInfo* PackageInfo_Metadata::mutable_exec_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.exec_jobs)
  return exec_jobs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ExecuteInfo >*
PackageInfo_Metadata::mutable_exec_jobs() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.Metadata.exec_jobs)
  return &exec_jobs_;
}
inline const ::proto::ExecuteInfo& PackageInfo_Metadata::exec_jobs(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.exec_jobs)
  return exec_jobs_.Get(index);
}
inline ::proto::ExecuteInfo* PackageInfo_Metadata::add_exec_jobs() {
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.exec_jobs)
  return exec_jobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ExecuteInfo >&
PackageInfo_Metadata::exec_jobs() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.Metadata.exec_jobs)
  return exec_jobs_;
}

// repeated string authors = 8;
inline int PackageInfo_Metadata::authors_size() const {
  return authors_.size();
}
inline void PackageInfo_Metadata::clear_authors() {
  authors_.Clear();
}
inline const ::std::string& PackageInfo_Metadata::authors(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.authors)
  return authors_.Get(index);
}
inline ::std::string* PackageInfo_Metadata::mutable_authors(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.authors)
  return authors_.Mutable(index);
}
inline void PackageInfo_Metadata::set_authors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.authors)
  authors_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_authors(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.authors)
  authors_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PackageInfo_Metadata::set_authors(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  authors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.authors)
}
inline void PackageInfo_Metadata::set_authors(int index, const char* value, size_t size) {
  authors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.authors)
}
inline ::std::string* PackageInfo_Metadata::add_authors() {
  // @@protoc_insertion_point(field_add_mutable:proto.PackageInfo.Metadata.authors)
  return authors_.Add();
}
inline void PackageInfo_Metadata::add_authors(const ::std::string& value) {
  authors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.authors)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::add_authors(::std::string&& value) {
  authors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.authors)
}
#endif
inline void PackageInfo_Metadata::add_authors(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  authors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.PackageInfo.Metadata.authors)
}
inline void PackageInfo_Metadata::add_authors(const char* value, size_t size) {
  authors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.PackageInfo.Metadata.authors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackageInfo_Metadata::authors() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.Metadata.authors)
  return authors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PackageInfo_Metadata::mutable_authors() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.Metadata.authors)
  return &authors_;
}

// repeated string contributors = 9;
inline int PackageInfo_Metadata::contributors_size() const {
  return contributors_.size();
}
inline void PackageInfo_Metadata::clear_contributors() {
  contributors_.Clear();
}
inline const ::std::string& PackageInfo_Metadata::contributors(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.contributors)
  return contributors_.Get(index);
}
inline ::std::string* PackageInfo_Metadata::mutable_contributors(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.contributors)
  return contributors_.Mutable(index);
}
inline void PackageInfo_Metadata::set_contributors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.contributors)
  contributors_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_contributors(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.contributors)
  contributors_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PackageInfo_Metadata::set_contributors(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  contributors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.contributors)
}
inline void PackageInfo_Metadata::set_contributors(int index, const char* value, size_t size) {
  contributors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.contributors)
}
inline ::std::string* PackageInfo_Metadata::add_contributors() {
  // @@protoc_insertion_point(field_add_mutable:proto.PackageInfo.Metadata.contributors)
  return contributors_.Add();
}
inline void PackageInfo_Metadata::add_contributors(const ::std::string& value) {
  contributors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.contributors)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::add_contributors(::std::string&& value) {
  contributors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.contributors)
}
#endif
inline void PackageInfo_Metadata::add_contributors(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  contributors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.PackageInfo.Metadata.contributors)
}
inline void PackageInfo_Metadata::add_contributors(const char* value, size_t size) {
  contributors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.PackageInfo.Metadata.contributors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackageInfo_Metadata::contributors() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.Metadata.contributors)
  return contributors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PackageInfo_Metadata::mutable_contributors() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.Metadata.contributors)
  return &contributors_;
}

// repeated string maintainers = 10;
inline int PackageInfo_Metadata::maintainers_size() const {
  return maintainers_.size();
}
inline void PackageInfo_Metadata::clear_maintainers() {
  maintainers_.Clear();
}
inline const ::std::string& PackageInfo_Metadata::maintainers(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.maintainers)
  return maintainers_.Get(index);
}
inline ::std::string* PackageInfo_Metadata::mutable_maintainers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.maintainers)
  return maintainers_.Mutable(index);
}
inline void PackageInfo_Metadata::set_maintainers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.maintainers)
  maintainers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PackageInfo_Metadata::set_maintainers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.PackageInfo.Metadata.maintainers)
  maintainers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PackageInfo_Metadata::set_maintainers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  maintainers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.PackageInfo.Metadata.maintainers)
}
inline void PackageInfo_Metadata::set_maintainers(int index, const char* value, size_t size) {
  maintainers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.PackageInfo.Metadata.maintainers)
}
inline ::std::string* PackageInfo_Metadata::add_maintainers() {
  // @@protoc_insertion_point(field_add_mutable:proto.PackageInfo.Metadata.maintainers)
  return maintainers_.Add();
}
inline void PackageInfo_Metadata::add_maintainers(const ::std::string& value) {
  maintainers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.maintainers)
}
#if LANG_CXX11
inline void PackageInfo_Metadata::add_maintainers(::std::string&& value) {
  maintainers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.maintainers)
}
#endif
inline void PackageInfo_Metadata::add_maintainers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  maintainers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.PackageInfo.Metadata.maintainers)
}
inline void PackageInfo_Metadata::add_maintainers(const char* value, size_t size) {
  maintainers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.PackageInfo.Metadata.maintainers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackageInfo_Metadata::maintainers() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.Metadata.maintainers)
  return maintainers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PackageInfo_Metadata::mutable_maintainers() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.Metadata.maintainers)
  return &maintainers_;
}

// repeated .proto.ReleaseInfo releases = 11;
inline int PackageInfo_Metadata::releases_size() const {
  return releases_.size();
}
inline void PackageInfo_Metadata::clear_releases() {
  releases_.Clear();
}
inline ::proto::ReleaseInfo* PackageInfo_Metadata::mutable_releases(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.Metadata.releases)
  return releases_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ReleaseInfo >*
PackageInfo_Metadata::mutable_releases() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.Metadata.releases)
  return &releases_;
}
inline const ::proto::ReleaseInfo& PackageInfo_Metadata::releases(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.Metadata.releases)
  return releases_.Get(index);
}
inline ::proto::ReleaseInfo* PackageInfo_Metadata::add_releases() {
  // @@protoc_insertion_point(field_add:proto.PackageInfo.Metadata.releases)
  return releases_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ReleaseInfo >&
PackageInfo_Metadata::releases() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.Metadata.releases)
  return releases_;
}

// -------------------------------------------------------------------

// PackageInfo

// .proto.PackageInfo.Metadata info = 1;
inline bool PackageInfo::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void PackageInfo::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::proto::PackageInfo_Metadata& PackageInfo::_internal_info() const {
  return *info_;
}
inline const ::proto::PackageInfo_Metadata& PackageInfo::info() const {
  const ::proto::PackageInfo_Metadata* p = info_;
  // @@protoc_insertion_point(field_get:proto.PackageInfo.info)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::PackageInfo_Metadata*>(
      &::proto::_PackageInfo_Metadata_default_instance_);
}
inline ::proto::PackageInfo_Metadata* PackageInfo::release_info() {
  // @@protoc_insertion_point(field_release:proto.PackageInfo.info)
  
  ::proto::PackageInfo_Metadata* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::proto::PackageInfo_Metadata* PackageInfo::mutable_info() {
  
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::PackageInfo_Metadata>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.info)
  return info_;
}
inline void PackageInfo::set_allocated_info(::proto::PackageInfo_Metadata* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:proto.PackageInfo.info)
}

// repeated .proto.PackageInfo.Metadata dependencies = 2;
inline int PackageInfo::dependencies_size() const {
  return dependencies_.size();
}
inline void PackageInfo::clear_dependencies() {
  dependencies_.Clear();
}
inline ::proto::PackageInfo_Metadata* PackageInfo::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.dependencies)
  return dependencies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >*
PackageInfo::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.dependencies)
  return &dependencies_;
}
inline const ::proto::PackageInfo_Metadata& PackageInfo::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.dependencies)
  return dependencies_.Get(index);
}
inline ::proto::PackageInfo_Metadata* PackageInfo::add_dependencies() {
  // @@protoc_insertion_point(field_add:proto.PackageInfo.dependencies)
  return dependencies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >&
PackageInfo::dependencies() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.dependencies)
  return dependencies_;
}

// repeated .proto.PackageInfo.Metadata dev_dependencies = 3;
inline int PackageInfo::dev_dependencies_size() const {
  return dev_dependencies_.size();
}
inline void PackageInfo::clear_dev_dependencies() {
  dev_dependencies_.Clear();
}
inline ::proto::PackageInfo_Metadata* PackageInfo::mutable_dev_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PackageInfo.dev_dependencies)
  return dev_dependencies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >*
PackageInfo::mutable_dev_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:proto.PackageInfo.dev_dependencies)
  return &dev_dependencies_;
}
inline const ::proto::PackageInfo_Metadata& PackageInfo::dev_dependencies(int index) const {
  // @@protoc_insertion_point(field_get:proto.PackageInfo.dev_dependencies)
  return dev_dependencies_.Get(index);
}
inline ::proto::PackageInfo_Metadata* PackageInfo::add_dev_dependencies() {
  // @@protoc_insertion_point(field_add:proto.PackageInfo.dev_dependencies)
  return dev_dependencies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::PackageInfo_Metadata >&
PackageInfo::dev_dependencies() const {
  // @@protoc_insertion_point(field_list:proto.PackageInfo.dev_dependencies)
  return dev_dependencies_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_info_2eproto
