// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ast.proto

#ifndef PROTOBUF_INCLUDED_ast_2eproto
#define PROTOBUF_INCLUDED_ast_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ast_2eproto 

namespace protobuf_ast_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ast_2eproto
namespace proto {
class AstLookupConfig;
class AstLookupConfigDefaultTypeInternal;
extern AstLookupConfigDefaultTypeInternal _AstLookupConfig_default_instance_;
class AstNode;
class AstNodeDefaultTypeInternal;
extern AstNodeDefaultTypeInternal _AstNode_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class PkgAstResult;
class PkgAstResultDefaultTypeInternal;
extern PkgAstResultDefaultTypeInternal _PkgAstResult_default_instance_;
class PkgAstResults;
class PkgAstResultsDefaultTypeInternal;
extern PkgAstResultsDefaultTypeInternal _PkgAstResults_default_instance_;
class SourceLocation;
class SourceLocationDefaultTypeInternal;
extern SourceLocationDefaultTypeInternal _SourceLocation_default_instance_;
class SourceRange;
class SourceRangeDefaultTypeInternal;
extern SourceRangeDefaultTypeInternal _SourceRange_default_instance_;
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::AstLookupConfig* Arena::CreateMaybeMessage<::proto::AstLookupConfig>(Arena*);
template<> ::proto::AstNode* Arena::CreateMaybeMessage<::proto::AstNode>(Arena*);
template<> ::proto::FileInfo* Arena::CreateMaybeMessage<::proto::FileInfo>(Arena*);
template<> ::proto::PkgAstResult* Arena::CreateMaybeMessage<::proto::PkgAstResult>(Arena*);
template<> ::proto::PkgAstResults* Arena::CreateMaybeMessage<::proto::PkgAstResults>(Arena*);
template<> ::proto::SourceLocation* Arena::CreateMaybeMessage<::proto::SourceLocation>(Arena*);
template<> ::proto::SourceRange* Arena::CreateMaybeMessage<::proto::SourceRange>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {

enum AstNode_NodeType {
  AstNode_NodeType_UNKNOWN = 0,
  AstNode_NodeType_FUNCTION_DECL = 1,
  AstNode_NodeType_VARIABLE_DECL = 2,
  AstNode_NodeType_CLASS_DECL = 3,
  AstNode_NodeType_FUNCTION_DECL_REF_EXPR = 11,
  AstNode_NodeType_VARIABLE_DECL_REF_EXPR = 12,
  AstNode_NodeType_CLASS_DECL_REF_EXPR = 13,
  AstNode_NodeType_PY_FUNCTION_DEF = 101,
  AstNode_NodeType_JS_ASSIGNMENT_EXPRESSION = 201,
  AstNode_NodeType_RB_REGULAR_NODE = 301,
  AstNode_NodeType_RB_VARIABLE_NODE = 302,
  AstNode_NodeType_JAVA_IDENTITY_STMT = 401,
  AstNode_NodeType_PHP_EXPR_VARIABLE = 501,
  AstNode_NodeType_AstNode_NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AstNode_NodeType_AstNode_NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AstNode_NodeType_IsValid(int value);
const AstNode_NodeType AstNode_NodeType_NodeType_MIN = AstNode_NodeType_UNKNOWN;
const AstNode_NodeType AstNode_NodeType_NodeType_MAX = AstNode_NodeType_PHP_EXPR_VARIABLE;
const int AstNode_NodeType_NodeType_ARRAYSIZE = AstNode_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AstNode_NodeType_descriptor();
inline const ::std::string& AstNode_NodeType_Name(AstNode_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AstNode_NodeType_descriptor(), value);
}
inline bool AstNode_NodeType_Parse(
    const ::std::string& name, AstNode_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AstNode_NodeType>(
    AstNode_NodeType_descriptor(), name, value);
}
enum Language {
  UNKNOWN = 0,
  PYTHON = 1,
  JAVASCRIPT = 2,
  RUBY = 3,
  JAVA = 4,
  PHP = 5,
  CSHARP = 6,
  CPP = 7,
  GO = 8,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Language_IsValid(int value);
const Language Language_MIN = UNKNOWN;
const Language Language_MAX = GO;
const int Language_ARRAYSIZE = Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_descriptor();
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_descriptor(), value);
}
inline bool Language_Parse(
    const ::std::string& name, Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum Functionality {
  UNCLASSIFIED = 0,
  SOURCE = 1,
  SINK = 2,
  DANGER = 3,
  PROPAGATE = 4,
  Functionality_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Functionality_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Functionality_IsValid(int value);
const Functionality Functionality_MIN = UNCLASSIFIED;
const Functionality Functionality_MAX = PROPAGATE;
const int Functionality_ARRAYSIZE = Functionality_MAX + 1;

const ::google::protobuf::EnumDescriptor* Functionality_descriptor();
inline const ::std::string& Functionality_Name(Functionality value) {
  return ::google::protobuf::internal::NameOfEnum(
    Functionality_descriptor(), value);
}
inline bool Functionality_Parse(
    const ::std::string& name, Functionality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Functionality>(
    Functionality_descriptor(), name, value);
}
enum SourceType {
  SOURCE_UNCLASSIFIED = 0,
  SOURCE_ACCOUNT = 1,
  SOURCE_BLUETOOTH = 2,
  SOURCE_BROWSER = 3,
  SOURCE_CALENDAR = 4,
  SOURCE_CONTACT = 5,
  SOURCE_DATABASE = 6,
  SOURCE_FILE = 7,
  SOURCE_NETWORK = 8,
  SOURCE_NFC = 9,
  SOURCE_SETTINGS = 10,
  SOURCE_SYNC = 11,
  SOURCE_UNIQUE_IDENTIFIER = 12,
  SOURCE_ENVIRONMENT = 51,
  SOURCE_USER_INPUT = 52,
  SOURCE_OBFUSCATION = 53,
  SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SourceType_IsValid(int value);
const SourceType SourceType_MIN = SOURCE_UNCLASSIFIED;
const SourceType SourceType_MAX = SOURCE_OBFUSCATION;
const int SourceType_ARRAYSIZE = SourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SourceType_descriptor();
inline const ::std::string& SourceType_Name(SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SourceType_descriptor(), value);
}
inline bool SourceType_Parse(
    const ::std::string& name, SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SourceType>(
    SourceType_descriptor(), name, value);
}
enum SinkType {
  SINK_UNCLASSIFIED = 0,
  SINK_ACCOUNT = 1,
  SINK_AUDIO = 2,
  SINK_BROWSER = 3,
  SINK_CALENDAR = 4,
  SINK_CONTACT = 5,
  SINK_FILE = 6,
  SINK_LOG = 7,
  SINK_NETWORK = 8,
  SINK_NFC = 9,
  SINK_PHONE_CONNECTION = 10,
  SINK_PHONE_STATE = 11,
  SINK_SMS_MMS = 12,
  SINK_SYNC = 13,
  SINK_SYSTEM = 14,
  SINK_VOIP = 15,
  SINK_CODE_GENERATION = 51,
  SINK_PROCESS_OPERATION = 52,
  SINK_DATABASE = 53,
  SinkType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SinkType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SinkType_IsValid(int value);
const SinkType SinkType_MIN = SINK_UNCLASSIFIED;
const SinkType SinkType_MAX = SINK_DATABASE;
const int SinkType_ARRAYSIZE = SinkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SinkType_descriptor();
inline const ::std::string& SinkType_Name(SinkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SinkType_descriptor(), value);
}
inline bool SinkType_Parse(
    const ::std::string& name, SinkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SinkType>(
    SinkType_descriptor(), name, value);
}
enum DangerType {
  DANGER_UNCLASSIFIED_DANGER = 0,
  DangerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DangerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DangerType_IsValid(int value);
const DangerType DangerType_MIN = DANGER_UNCLASSIFIED_DANGER;
const DangerType DangerType_MAX = DANGER_UNCLASSIFIED_DANGER;
const int DangerType_ARRAYSIZE = DangerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DangerType_descriptor();
inline const ::std::string& DangerType_Name(DangerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DangerType_descriptor(), value);
}
inline bool DangerType_Parse(
    const ::std::string& name, DangerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DangerType>(
    DangerType_descriptor(), name, value);
}
enum PropagateType {
  PROPAGATE_UNCLASSIFIED = 0,
  PROPAGATE_ASSIGN = 1,
  PROPAGATE_CALL = 2,
  PROPAGATE_SYSCALL = 3,
  PROPAGATE_LIBCALL = 4,
  PropagateType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PropagateType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PropagateType_IsValid(int value);
const PropagateType PropagateType_MIN = PROPAGATE_UNCLASSIFIED;
const PropagateType PropagateType_MAX = PROPAGATE_LIBCALL;
const int PropagateType_ARRAYSIZE = PropagateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PropagateType_descriptor();
inline const ::std::string& PropagateType_Name(PropagateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PropagateType_descriptor(), value);
}
inline bool PropagateType_Parse(
    const ::std::string& name, PropagateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PropagateType>(
    PropagateType_descriptor(), name, value);
}
// ===================================================================

class FileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FileInfo* other);
  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const final {
    return CreateMaybeMessage<FileInfo>(NULL);
  }

  FileInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // string relpath = 2;
  void clear_relpath();
  static const int kRelpathFieldNumber = 2;
  const ::std::string& relpath() const;
  void set_relpath(const ::std::string& value);
  #if LANG_CXX11
  void set_relpath(::std::string&& value);
  #endif
  void set_relpath(const char* value);
  void set_relpath(const char* value, size_t size);
  ::std::string* mutable_relpath();
  ::std::string* release_relpath();
  void set_allocated_relpath(::std::string* relpath);

  // string file = 3;
  void clear_file();
  static const int kFileFieldNumber = 3;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // string directory = 4;
  void clear_directory();
  static const int kDirectoryFieldNumber = 4;
  const ::std::string& directory() const;
  void set_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_directory(::std::string&& value);
  #endif
  void set_directory(const char* value);
  void set_directory(const char* value, size_t size);
  ::std::string* mutable_directory();
  ::std::string* release_directory();
  void set_allocated_directory(::std::string* directory);

  // @@protoc_insertion_point(class_scope:proto.FileInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr relpath_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::internal::ArenaStringPtr directory_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SourceLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.SourceLocation) */ {
 public:
  SourceLocation();
  virtual ~SourceLocation();

  SourceLocation(const SourceLocation& from);

  inline SourceLocation& operator=(const SourceLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SourceLocation(SourceLocation&& from) noexcept
    : SourceLocation() {
    *this = ::std::move(from);
  }

  inline SourceLocation& operator=(SourceLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SourceLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SourceLocation* internal_default_instance() {
    return reinterpret_cast<const SourceLocation*>(
               &_SourceLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SourceLocation* other);
  friend void swap(SourceLocation& a, SourceLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SourceLocation* New() const final {
    return CreateMaybeMessage<SourceLocation>(NULL);
  }

  SourceLocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SourceLocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SourceLocation& from);
  void MergeFrom(const SourceLocation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.FileInfo file_info = 3;
  bool has_file_info() const;
  void clear_file_info();
  static const int kFileInfoFieldNumber = 3;
  private:
  const ::proto::FileInfo& _internal_file_info() const;
  public:
  const ::proto::FileInfo& file_info() const;
  ::proto::FileInfo* release_file_info();
  ::proto::FileInfo* mutable_file_info();
  void set_allocated_file_info(::proto::FileInfo* file_info);

  // int32 row = 1;
  void clear_row();
  static const int kRowFieldNumber = 1;
  ::google::protobuf::int32 row() const;
  void set_row(::google::protobuf::int32 value);

  // int32 column = 2;
  void clear_column();
  static const int kColumnFieldNumber = 2;
  ::google::protobuf::int32 column() const;
  void set_column(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.SourceLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::FileInfo* file_info_;
  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 column_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SourceRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.SourceRange) */ {
 public:
  SourceRange();
  virtual ~SourceRange();

  SourceRange(const SourceRange& from);

  inline SourceRange& operator=(const SourceRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SourceRange(SourceRange&& from) noexcept
    : SourceRange() {
    *this = ::std::move(from);
  }

  inline SourceRange& operator=(SourceRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SourceRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SourceRange* internal_default_instance() {
    return reinterpret_cast<const SourceRange*>(
               &_SourceRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SourceRange* other);
  friend void swap(SourceRange& a, SourceRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SourceRange* New() const final {
    return CreateMaybeMessage<SourceRange>(NULL);
  }

  SourceRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SourceRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SourceRange& from);
  void MergeFrom(const SourceRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.SourceLocation start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::proto::SourceLocation& _internal_start() const;
  public:
  const ::proto::SourceLocation& start() const;
  ::proto::SourceLocation* release_start();
  ::proto::SourceLocation* mutable_start();
  void set_allocated_start(::proto::SourceLocation* start);

  // .proto.SourceLocation end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  private:
  const ::proto::SourceLocation& _internal_end() const;
  public:
  const ::proto::SourceLocation& end() const;
  ::proto::SourceLocation* release_end();
  ::proto::SourceLocation* mutable_end();
  void set_allocated_end(::proto::SourceLocation* end);

  // @@protoc_insertion_point(class_scope:proto.SourceRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::proto::SourceLocation* start_;
  ::proto::SourceLocation* end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AstNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.AstNode) */ {
 public:
  AstNode();
  virtual ~AstNode();

  AstNode(const AstNode& from);

  inline AstNode& operator=(const AstNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AstNode(AstNode&& from) noexcept
    : AstNode() {
    *this = ::std::move(from);
  }

  inline AstNode& operator=(AstNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AstNode& default_instance();

  enum AccurateFunctionalityCase {
    kSourceType = 14,
    kSinkType = 15,
    kDangerType = 16,
    kPropagateType = 17,
    ACCURATE_FUNCTIONALITY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AstNode* internal_default_instance() {
    return reinterpret_cast<const AstNode*>(
               &_AstNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AstNode* other);
  friend void swap(AstNode& a, AstNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AstNode* New() const final {
    return CreateMaybeMessage<AstNode>(NULL);
  }

  AstNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AstNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AstNode& from);
  void MergeFrom(const AstNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AstNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AstNode_NodeType NodeType;
  static const NodeType UNKNOWN =
    AstNode_NodeType_UNKNOWN;
  static const NodeType FUNCTION_DECL =
    AstNode_NodeType_FUNCTION_DECL;
  static const NodeType VARIABLE_DECL =
    AstNode_NodeType_VARIABLE_DECL;
  static const NodeType CLASS_DECL =
    AstNode_NodeType_CLASS_DECL;
  static const NodeType FUNCTION_DECL_REF_EXPR =
    AstNode_NodeType_FUNCTION_DECL_REF_EXPR;
  static const NodeType VARIABLE_DECL_REF_EXPR =
    AstNode_NodeType_VARIABLE_DECL_REF_EXPR;
  static const NodeType CLASS_DECL_REF_EXPR =
    AstNode_NodeType_CLASS_DECL_REF_EXPR;
  static const NodeType PY_FUNCTION_DEF =
    AstNode_NodeType_PY_FUNCTION_DEF;
  static const NodeType JS_ASSIGNMENT_EXPRESSION =
    AstNode_NodeType_JS_ASSIGNMENT_EXPRESSION;
  static const NodeType RB_REGULAR_NODE =
    AstNode_NodeType_RB_REGULAR_NODE;
  static const NodeType RB_VARIABLE_NODE =
    AstNode_NodeType_RB_VARIABLE_NODE;
  static const NodeType JAVA_IDENTITY_STMT =
    AstNode_NodeType_JAVA_IDENTITY_STMT;
  static const NodeType PHP_EXPR_VARIABLE =
    AstNode_NodeType_PHP_EXPR_VARIABLE;
  static inline bool NodeType_IsValid(int value) {
    return AstNode_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    AstNode_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    AstNode_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    AstNode_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return AstNode_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return AstNode_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return AstNode_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode arg_nodes = 8;
  int arg_nodes_size() const;
  void clear_arg_nodes();
  static const int kArgNodesFieldNumber = 8;
  ::proto::AstNode* mutable_arg_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_arg_nodes();
  const ::proto::AstNode& arg_nodes(int index) const;
  ::proto::AstNode* add_arg_nodes();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      arg_nodes() const;

  // repeated string arguments = 9;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 9;
  const ::std::string& arguments(int index) const;
  ::std::string* mutable_arguments(int index);
  void set_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_arguments(int index, ::std::string&& value);
  #endif
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  ::std::string* add_arguments();
  void add_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_arguments(::std::string&& value);
  #endif
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // repeated .proto.AstNode child_nodes = 18;
  int child_nodes_size() const;
  void clear_child_nodes();
  static const int kChildNodesFieldNumber = 18;
  ::proto::AstNode* mutable_child_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_child_nodes();
  const ::proto::AstNode& child_nodes(int index) const;
  ::proto::AstNode* add_child_nodes();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      child_nodes() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string full_name = 3;
  void clear_full_name();
  static const int kFullNameFieldNumber = 3;
  const ::std::string& full_name() const;
  void set_full_name(const ::std::string& value);
  #if LANG_CXX11
  void set_full_name(::std::string&& value);
  #endif
  void set_full_name(const char* value);
  void set_full_name(const char* value, size_t size);
  ::std::string* mutable_full_name();
  ::std::string* release_full_name();
  void set_allocated_full_name(::std::string* full_name);

  // string base_type = 4;
  void clear_base_type();
  static const int kBaseTypeFieldNumber = 4;
  const ::std::string& base_type() const;
  void set_base_type(const ::std::string& value);
  #if LANG_CXX11
  void set_base_type(::std::string&& value);
  #endif
  void set_base_type(const char* value);
  void set_base_type(const char* value, size_t size);
  ::std::string* mutable_base_type();
  ::std::string* release_base_type();
  void set_allocated_base_type(::std::string* base_type);

  // string module = 5;
  void clear_module();
  static const int kModuleFieldNumber = 5;
  const ::std::string& module() const;
  void set_module(const ::std::string& value);
  #if LANG_CXX11
  void set_module(::std::string&& value);
  #endif
  void set_module(const char* value);
  void set_module(const char* value, size_t size);
  ::std::string* mutable_module();
  ::std::string* release_module();
  void set_allocated_module(::std::string* module);

  // string value = 6;
  void clear_value();
  static const int kValueFieldNumber = 6;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string definition = 7;
  void clear_definition();
  static const int kDefinitionFieldNumber = 7;
  const ::std::string& definition() const;
  void set_definition(const ::std::string& value);
  #if LANG_CXX11
  void set_definition(::std::string&& value);
  #endif
  void set_definition(const char* value);
  void set_definition(const char* value, size_t size);
  ::std::string* mutable_definition();
  ::std::string* release_definition();
  void set_allocated_definition(::std::string* definition);

  // string source = 10;
  void clear_source();
  static const int kSourceFieldNumber = 10;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // .proto.SourceRange range = 11;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 11;
  private:
  const ::proto::SourceRange& _internal_range() const;
  public:
  const ::proto::SourceRange& range() const;
  ::proto::SourceRange* release_range();
  ::proto::SourceRange* mutable_range();
  void set_allocated_range(::proto::SourceRange* range);

  // .proto.AstNode.NodeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::AstNode_NodeType type() const;
  void set_type(::proto::AstNode_NodeType value);

  // int32 id = 12;
  void clear_id();
  static const int kIdFieldNumber = 12;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .proto.Functionality functionality = 13;
  void clear_functionality();
  static const int kFunctionalityFieldNumber = 13;
  ::proto::Functionality functionality() const;
  void set_functionality(::proto::Functionality value);

  // bool instantiatable = 19;
  void clear_instantiatable();
  static const int kInstantiatableFieldNumber = 19;
  bool instantiatable() const;
  void set_instantiatable(bool value);

  // .proto.SourceType source_type = 14;
  private:
  bool has_source_type() const;
  public:
  void clear_source_type();
  static const int kSourceTypeFieldNumber = 14;
  ::proto::SourceType source_type() const;
  void set_source_type(::proto::SourceType value);

  // .proto.SinkType sink_type = 15;
  private:
  bool has_sink_type() const;
  public:
  void clear_sink_type();
  static const int kSinkTypeFieldNumber = 15;
  ::proto::SinkType sink_type() const;
  void set_sink_type(::proto::SinkType value);

  // .proto.DangerType danger_type = 16;
  private:
  bool has_danger_type() const;
  public:
  void clear_danger_type();
  static const int kDangerTypeFieldNumber = 16;
  ::proto::DangerType danger_type() const;
  void set_danger_type(::proto::DangerType value);

  // .proto.PropagateType propagate_type = 17;
  private:
  bool has_propagate_type() const;
  public:
  void clear_propagate_type();
  static const int kPropagateTypeFieldNumber = 17;
  ::proto::PropagateType propagate_type() const;
  void set_propagate_type(::proto::PropagateType value);

  void clear_accurate_functionality();
  AccurateFunctionalityCase accurate_functionality_case() const;
  // @@protoc_insertion_point(class_scope:proto.AstNode)
 private:
  void set_has_source_type();
  void set_has_sink_type();
  void set_has_danger_type();
  void set_has_propagate_type();

  inline bool has_accurate_functionality() const;
  inline void clear_has_accurate_functionality();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > arg_nodes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > child_nodes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr full_name_;
  ::google::protobuf::internal::ArenaStringPtr base_type_;
  ::google::protobuf::internal::ArenaStringPtr module_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr definition_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::proto::SourceRange* range_;
  int type_;
  ::google::protobuf::int32 id_;
  int functionality_;
  bool instantiatable_;
  union AccurateFunctionalityUnion {
    AccurateFunctionalityUnion() {}
    int source_type_;
    int sink_type_;
    int danger_type_;
    int propagate_type_;
  } accurate_functionality_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AstLookupConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.AstLookupConfig) */ {
 public:
  AstLookupConfig();
  virtual ~AstLookupConfig();

  AstLookupConfig(const AstLookupConfig& from);

  inline AstLookupConfig& operator=(const AstLookupConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AstLookupConfig(AstLookupConfig&& from) noexcept
    : AstLookupConfig() {
    *this = ::std::move(from);
  }

  inline AstLookupConfig& operator=(AstLookupConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AstLookupConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AstLookupConfig* internal_default_instance() {
    return reinterpret_cast<const AstLookupConfig*>(
               &_AstLookupConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AstLookupConfig* other);
  friend void swap(AstLookupConfig& a, AstLookupConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AstLookupConfig* New() const final {
    return CreateMaybeMessage<AstLookupConfig>(NULL);
  }

  AstLookupConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AstLookupConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AstLookupConfig& from);
  void MergeFrom(const AstLookupConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AstLookupConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode apis = 1;
  int apis_size() const;
  void clear_apis();
  static const int kApisFieldNumber = 1;
  ::proto::AstNode* mutable_apis(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_apis();
  const ::proto::AstNode& apis(int index) const;
  ::proto::AstNode* add_apis();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      apis() const;

  // string smt_formula = 3;
  void clear_smt_formula();
  static const int kSmtFormulaFieldNumber = 3;
  const ::std::string& smt_formula() const;
  void set_smt_formula(const ::std::string& value);
  #if LANG_CXX11
  void set_smt_formula(::std::string&& value);
  #endif
  void set_smt_formula(const char* value);
  void set_smt_formula(const char* value, size_t size);
  ::std::string* mutable_smt_formula();
  ::std::string* release_smt_formula();
  void set_allocated_smt_formula(::std::string* smt_formula);

  // bool save_feature = 2;
  void clear_save_feature();
  static const int kSaveFeatureFieldNumber = 2;
  bool save_feature() const;
  void set_save_feature(bool value);

  // bool smt_satisfied = 4;
  void clear_smt_satisfied();
  static const int kSmtSatisfiedFieldNumber = 4;
  bool smt_satisfied() const;
  void set_smt_satisfied(bool value);

  // bool func_only = 5;
  void clear_func_only();
  static const int kFuncOnlyFieldNumber = 5;
  bool func_only() const;
  void set_func_only(bool value);

  // @@protoc_insertion_point(class_scope:proto.AstLookupConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > apis_;
  ::google::protobuf::internal::ArenaStringPtr smt_formula_;
  bool save_feature_;
  bool smt_satisfied_;
  bool func_only_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PkgAstResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.PkgAstResult) */ {
 public:
  PkgAstResult();
  virtual ~PkgAstResult();

  PkgAstResult(const PkgAstResult& from);

  inline PkgAstResult& operator=(const PkgAstResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PkgAstResult(PkgAstResult&& from) noexcept
    : PkgAstResult() {
    *this = ::std::move(from);
  }

  inline PkgAstResult& operator=(PkgAstResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PkgAstResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PkgAstResult* internal_default_instance() {
    return reinterpret_cast<const PkgAstResult*>(
               &_PkgAstResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PkgAstResult* other);
  friend void swap(PkgAstResult& a, PkgAstResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PkgAstResult* New() const final {
    return CreateMaybeMessage<PkgAstResult>(NULL);
  }

  PkgAstResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PkgAstResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PkgAstResult& from);
  void MergeFrom(const PkgAstResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PkgAstResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.AstNode api_results = 6;
  int api_results_size() const;
  void clear_api_results();
  static const int kApiResultsFieldNumber = 6;
  ::proto::AstNode* mutable_api_results(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_api_results();
  const ::proto::AstNode& api_results(int index) const;
  ::proto::AstNode* add_api_results();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      api_results() const;

  // repeated .proto.AstNode root_nodes = 7;
  int root_nodes_size() const;
  void clear_root_nodes();
  static const int kRootNodesFieldNumber = 7;
  ::proto::AstNode* mutable_root_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
      mutable_root_nodes();
  const ::proto::AstNode& root_nodes(int index) const;
  ::proto::AstNode* add_root_nodes();
  const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
      root_nodes() const;

  // string pkg_name = 1;
  void clear_pkg_name();
  static const int kPkgNameFieldNumber = 1;
  const ::std::string& pkg_name() const;
  void set_pkg_name(const ::std::string& value);
  #if LANG_CXX11
  void set_pkg_name(::std::string&& value);
  #endif
  void set_pkg_name(const char* value);
  void set_pkg_name(const char* value, size_t size);
  ::std::string* mutable_pkg_name();
  ::std::string* release_pkg_name();
  void set_allocated_pkg_name(::std::string* pkg_name);

  // string pkg_version = 2;
  void clear_pkg_version();
  static const int kPkgVersionFieldNumber = 2;
  const ::std::string& pkg_version() const;
  void set_pkg_version(const ::std::string& value);
  #if LANG_CXX11
  void set_pkg_version(::std::string&& value);
  #endif
  void set_pkg_version(const char* value);
  void set_pkg_version(const char* value, size_t size);
  ::std::string* mutable_pkg_version();
  ::std::string* release_pkg_version();
  void set_allocated_pkg_version(::std::string* pkg_version);

  // string input_path = 4;
  void clear_input_path();
  static const int kInputPathFieldNumber = 4;
  const ::std::string& input_path() const;
  void set_input_path(const ::std::string& value);
  #if LANG_CXX11
  void set_input_path(::std::string&& value);
  #endif
  void set_input_path(const char* value);
  void set_input_path(const char* value, size_t size);
  ::std::string* mutable_input_path();
  ::std::string* release_input_path();
  void set_allocated_input_path(::std::string* input_path);

  // .proto.AstLookupConfig config = 5;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 5;
  private:
  const ::proto::AstLookupConfig& _internal_config() const;
  public:
  const ::proto::AstLookupConfig& config() const;
  ::proto::AstLookupConfig* release_config();
  ::proto::AstLookupConfig* mutable_config();
  void set_allocated_config(::proto::AstLookupConfig* config);

  // .proto.Language language = 3;
  void clear_language();
  static const int kLanguageFieldNumber = 3;
  ::proto::Language language() const;
  void set_language(::proto::Language value);

  // @@protoc_insertion_point(class_scope:proto.PkgAstResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > api_results_;
  ::google::protobuf::RepeatedPtrField< ::proto::AstNode > root_nodes_;
  ::google::protobuf::internal::ArenaStringPtr pkg_name_;
  ::google::protobuf::internal::ArenaStringPtr pkg_version_;
  ::google::protobuf::internal::ArenaStringPtr input_path_;
  ::proto::AstLookupConfig* config_;
  int language_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PkgAstResults : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.PkgAstResults) */ {
 public:
  PkgAstResults();
  virtual ~PkgAstResults();

  PkgAstResults(const PkgAstResults& from);

  inline PkgAstResults& operator=(const PkgAstResults& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PkgAstResults(PkgAstResults&& from) noexcept
    : PkgAstResults() {
    *this = ::std::move(from);
  }

  inline PkgAstResults& operator=(PkgAstResults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PkgAstResults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PkgAstResults* internal_default_instance() {
    return reinterpret_cast<const PkgAstResults*>(
               &_PkgAstResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PkgAstResults* other);
  friend void swap(PkgAstResults& a, PkgAstResults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PkgAstResults* New() const final {
    return CreateMaybeMessage<PkgAstResults>(NULL);
  }

  PkgAstResults* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PkgAstResults>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PkgAstResults& from);
  void MergeFrom(const PkgAstResults& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PkgAstResults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.PkgAstResult pkgs = 1;
  int pkgs_size() const;
  void clear_pkgs();
  static const int kPkgsFieldNumber = 1;
  ::proto::PkgAstResult* mutable_pkgs(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::PkgAstResult >*
      mutable_pkgs();
  const ::proto::PkgAstResult& pkgs(int index) const;
  ::proto::PkgAstResult* add_pkgs();
  const ::google::protobuf::RepeatedPtrField< ::proto::PkgAstResult >&
      pkgs() const;

  // uint64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.PkgAstResults)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::PkgAstResult > pkgs_;
  ::google::protobuf::uint64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ast_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileInfo

// string filename = 1;
inline void FileInfo::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::filename() const {
  // @@protoc_insertion_point(field_get:proto.FileInfo.filename)
  return filename_.GetNoArena();
}
inline void FileInfo::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.FileInfo.filename)
}
#if LANG_CXX11
inline void FileInfo::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.FileInfo.filename)
}
#endif
inline void FileInfo::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.FileInfo.filename)
}
inline void FileInfo::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.FileInfo.filename)
}
inline ::std::string* FileInfo::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:proto.FileInfo.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_filename() {
  // @@protoc_insertion_point(field_release:proto.FileInfo.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:proto.FileInfo.filename)
}

// string relpath = 2;
inline void FileInfo::clear_relpath() {
  relpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::relpath() const {
  // @@protoc_insertion_point(field_get:proto.FileInfo.relpath)
  return relpath_.GetNoArena();
}
inline void FileInfo::set_relpath(const ::std::string& value) {
  
  relpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.FileInfo.relpath)
}
#if LANG_CXX11
inline void FileInfo::set_relpath(::std::string&& value) {
  
  relpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.FileInfo.relpath)
}
#endif
inline void FileInfo::set_relpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  relpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.FileInfo.relpath)
}
inline void FileInfo::set_relpath(const char* value, size_t size) {
  
  relpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.FileInfo.relpath)
}
inline ::std::string* FileInfo::mutable_relpath() {
  
  // @@protoc_insertion_point(field_mutable:proto.FileInfo.relpath)
  return relpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_relpath() {
  // @@protoc_insertion_point(field_release:proto.FileInfo.relpath)
  
  return relpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_relpath(::std::string* relpath) {
  if (relpath != NULL) {
    
  } else {
    
  }
  relpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relpath);
  // @@protoc_insertion_point(field_set_allocated:proto.FileInfo.relpath)
}

// string file = 3;
inline void FileInfo::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::file() const {
  // @@protoc_insertion_point(field_get:proto.FileInfo.file)
  return file_.GetNoArena();
}
inline void FileInfo::set_file(const ::std::string& value) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.FileInfo.file)
}
#if LANG_CXX11
inline void FileInfo::set_file(::std::string&& value) {
  
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.FileInfo.file)
}
#endif
inline void FileInfo::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.FileInfo.file)
}
inline void FileInfo::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.FileInfo.file)
}
inline ::std::string* FileInfo::mutable_file() {
  
  // @@protoc_insertion_point(field_mutable:proto.FileInfo.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_file() {
  // @@protoc_insertion_point(field_release:proto.FileInfo.file)
  
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:proto.FileInfo.file)
}

// string directory = 4;
inline void FileInfo::clear_directory() {
  directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::directory() const {
  // @@protoc_insertion_point(field_get:proto.FileInfo.directory)
  return directory_.GetNoArena();
}
inline void FileInfo::set_directory(const ::std::string& value) {
  
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.FileInfo.directory)
}
#if LANG_CXX11
inline void FileInfo::set_directory(::std::string&& value) {
  
  directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.FileInfo.directory)
}
#endif
inline void FileInfo::set_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.FileInfo.directory)
}
inline void FileInfo::set_directory(const char* value, size_t size) {
  
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.FileInfo.directory)
}
inline ::std::string* FileInfo::mutable_directory() {
  
  // @@protoc_insertion_point(field_mutable:proto.FileInfo.directory)
  return directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_directory() {
  // @@protoc_insertion_point(field_release:proto.FileInfo.directory)
  
  return directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_directory(::std::string* directory) {
  if (directory != NULL) {
    
  } else {
    
  }
  directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), directory);
  // @@protoc_insertion_point(field_set_allocated:proto.FileInfo.directory)
}

// -------------------------------------------------------------------

// SourceLocation

// int32 row = 1;
inline void SourceLocation::clear_row() {
  row_ = 0;
}
inline ::google::protobuf::int32 SourceLocation::row() const {
  // @@protoc_insertion_point(field_get:proto.SourceLocation.row)
  return row_;
}
inline void SourceLocation::set_row(::google::protobuf::int32 value) {
  
  row_ = value;
  // @@protoc_insertion_point(field_set:proto.SourceLocation.row)
}

// int32 column = 2;
inline void SourceLocation::clear_column() {
  column_ = 0;
}
inline ::google::protobuf::int32 SourceLocation::column() const {
  // @@protoc_insertion_point(field_get:proto.SourceLocation.column)
  return column_;
}
inline void SourceLocation::set_column(::google::protobuf::int32 value) {
  
  column_ = value;
  // @@protoc_insertion_point(field_set:proto.SourceLocation.column)
}

// .proto.FileInfo file_info = 3;
inline bool SourceLocation::has_file_info() const {
  return this != internal_default_instance() && file_info_ != NULL;
}
inline void SourceLocation::clear_file_info() {
  if (GetArenaNoVirtual() == NULL && file_info_ != NULL) {
    delete file_info_;
  }
  file_info_ = NULL;
}
inline const ::proto::FileInfo& SourceLocation::_internal_file_info() const {
  return *file_info_;
}
inline const ::proto::FileInfo& SourceLocation::file_info() const {
  const ::proto::FileInfo* p = file_info_;
  // @@protoc_insertion_point(field_get:proto.SourceLocation.file_info)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::FileInfo*>(
      &::proto::_FileInfo_default_instance_);
}
inline ::proto::FileInfo* SourceLocation::release_file_info() {
  // @@protoc_insertion_point(field_release:proto.SourceLocation.file_info)
  
  ::proto::FileInfo* temp = file_info_;
  file_info_ = NULL;
  return temp;
}
inline ::proto::FileInfo* SourceLocation::mutable_file_info() {
  
  if (file_info_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::FileInfo>(GetArenaNoVirtual());
    file_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.SourceLocation.file_info)
  return file_info_;
}
inline void SourceLocation::set_allocated_file_info(::proto::FileInfo* file_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete file_info_;
  }
  if (file_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file_info, submessage_arena);
    }
    
  } else {
    
  }
  file_info_ = file_info;
  // @@protoc_insertion_point(field_set_allocated:proto.SourceLocation.file_info)
}

// -------------------------------------------------------------------

// SourceRange

// .proto.SourceLocation start = 1;
inline bool SourceRange::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void SourceRange::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::proto::SourceLocation& SourceRange::_internal_start() const {
  return *start_;
}
inline const ::proto::SourceLocation& SourceRange::start() const {
  const ::proto::SourceLocation* p = start_;
  // @@protoc_insertion_point(field_get:proto.SourceRange.start)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::SourceLocation*>(
      &::proto::_SourceLocation_default_instance_);
}
inline ::proto::SourceLocation* SourceRange::release_start() {
  // @@protoc_insertion_point(field_release:proto.SourceRange.start)
  
  ::proto::SourceLocation* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::proto::SourceLocation* SourceRange::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::SourceLocation>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.SourceRange.start)
  return start_;
}
inline void SourceRange::set_allocated_start(::proto::SourceLocation* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:proto.SourceRange.start)
}

// .proto.SourceLocation end = 2;
inline bool SourceRange::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void SourceRange::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::proto::SourceLocation& SourceRange::_internal_end() const {
  return *end_;
}
inline const ::proto::SourceLocation& SourceRange::end() const {
  const ::proto::SourceLocation* p = end_;
  // @@protoc_insertion_point(field_get:proto.SourceRange.end)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::SourceLocation*>(
      &::proto::_SourceLocation_default_instance_);
}
inline ::proto::SourceLocation* SourceRange::release_end() {
  // @@protoc_insertion_point(field_release:proto.SourceRange.end)
  
  ::proto::SourceLocation* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::proto::SourceLocation* SourceRange::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::SourceLocation>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.SourceRange.end)
  return end_;
}
inline void SourceRange::set_allocated_end(::proto::SourceLocation* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:proto.SourceRange.end)
}

// -------------------------------------------------------------------

// AstNode

// .proto.AstNode.NodeType type = 1;
inline void AstNode::clear_type() {
  type_ = 0;
}
inline ::proto::AstNode_NodeType AstNode::type() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.type)
  return static_cast< ::proto::AstNode_NodeType >(type_);
}
inline void AstNode::set_type(::proto::AstNode_NodeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.type)
}

// string name = 2;
inline void AstNode::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::name() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.name)
  return name_.GetNoArena();
}
inline void AstNode::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.name)
}
#if LANG_CXX11
inline void AstNode::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.name)
}
#endif
inline void AstNode::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.name)
}
inline void AstNode::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.name)
}
inline ::std::string* AstNode::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_name() {
  // @@protoc_insertion_point(field_release:proto.AstNode.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.name)
}

// string full_name = 3;
inline void AstNode::clear_full_name() {
  full_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::full_name() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.full_name)
  return full_name_.GetNoArena();
}
inline void AstNode::set_full_name(const ::std::string& value) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.full_name)
}
#if LANG_CXX11
inline void AstNode::set_full_name(::std::string&& value) {
  
  full_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.full_name)
}
#endif
inline void AstNode::set_full_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.full_name)
}
inline void AstNode::set_full_name(const char* value, size_t size) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.full_name)
}
inline ::std::string* AstNode::mutable_full_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.full_name)
  return full_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_full_name() {
  // @@protoc_insertion_point(field_release:proto.AstNode.full_name)
  
  return full_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_full_name(::std::string* full_name) {
  if (full_name != NULL) {
    
  } else {
    
  }
  full_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_name);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.full_name)
}

// string base_type = 4;
inline void AstNode::clear_base_type() {
  base_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::base_type() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.base_type)
  return base_type_.GetNoArena();
}
inline void AstNode::set_base_type(const ::std::string& value) {
  
  base_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.base_type)
}
#if LANG_CXX11
inline void AstNode::set_base_type(::std::string&& value) {
  
  base_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.base_type)
}
#endif
inline void AstNode::set_base_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  base_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.base_type)
}
inline void AstNode::set_base_type(const char* value, size_t size) {
  
  base_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.base_type)
}
inline ::std::string* AstNode::mutable_base_type() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.base_type)
  return base_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_base_type() {
  // @@protoc_insertion_point(field_release:proto.AstNode.base_type)
  
  return base_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_base_type(::std::string* base_type) {
  if (base_type != NULL) {
    
  } else {
    
  }
  base_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base_type);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.base_type)
}

// string module = 5;
inline void AstNode::clear_module() {
  module_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::module() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.module)
  return module_.GetNoArena();
}
inline void AstNode::set_module(const ::std::string& value) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.module)
}
#if LANG_CXX11
inline void AstNode::set_module(::std::string&& value) {
  
  module_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.module)
}
#endif
inline void AstNode::set_module(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.module)
}
inline void AstNode::set_module(const char* value, size_t size) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.module)
}
inline ::std::string* AstNode::mutable_module() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.module)
  return module_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_module() {
  // @@protoc_insertion_point(field_release:proto.AstNode.module)
  
  return module_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_module(::std::string* module) {
  if (module != NULL) {
    
  } else {
    
  }
  module_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.module)
}

// string value = 6;
inline void AstNode::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::value() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.value)
  return value_.GetNoArena();
}
inline void AstNode::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.value)
}
#if LANG_CXX11
inline void AstNode::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.value)
}
#endif
inline void AstNode::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.value)
}
inline void AstNode::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.value)
}
inline ::std::string* AstNode::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_value() {
  // @@protoc_insertion_point(field_release:proto.AstNode.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.value)
}

// string definition = 7;
inline void AstNode::clear_definition() {
  definition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::definition() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.definition)
  return definition_.GetNoArena();
}
inline void AstNode::set_definition(const ::std::string& value) {
  
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.definition)
}
#if LANG_CXX11
inline void AstNode::set_definition(::std::string&& value) {
  
  definition_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.definition)
}
#endif
inline void AstNode::set_definition(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.definition)
}
inline void AstNode::set_definition(const char* value, size_t size) {
  
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.definition)
}
inline ::std::string* AstNode::mutable_definition() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.definition)
  return definition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_definition() {
  // @@protoc_insertion_point(field_release:proto.AstNode.definition)
  
  return definition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_definition(::std::string* definition) {
  if (definition != NULL) {
    
  } else {
    
  }
  definition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), definition);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.definition)
}

// repeated .proto.AstNode arg_nodes = 8;
inline int AstNode::arg_nodes_size() const {
  return arg_nodes_.size();
}
inline void AstNode::clear_arg_nodes() {
  arg_nodes_.Clear();
}
inline ::proto::AstNode* AstNode::mutable_arg_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AstNode.arg_nodes)
  return arg_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
AstNode::mutable_arg_nodes() {
  // @@protoc_insertion_point(field_mutable_list:proto.AstNode.arg_nodes)
  return &arg_nodes_;
}
inline const ::proto::AstNode& AstNode::arg_nodes(int index) const {
  // @@protoc_insertion_point(field_get:proto.AstNode.arg_nodes)
  return arg_nodes_.Get(index);
}
inline ::proto::AstNode* AstNode::add_arg_nodes() {
  // @@protoc_insertion_point(field_add:proto.AstNode.arg_nodes)
  return arg_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
AstNode::arg_nodes() const {
  // @@protoc_insertion_point(field_list:proto.AstNode.arg_nodes)
  return arg_nodes_;
}

// repeated string arguments = 9;
inline int AstNode::arguments_size() const {
  return arguments_.size();
}
inline void AstNode::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& AstNode::arguments(int index) const {
  // @@protoc_insertion_point(field_get:proto.AstNode.arguments)
  return arguments_.Get(index);
}
inline ::std::string* AstNode::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AstNode.arguments)
  return arguments_.Mutable(index);
}
inline void AstNode::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.AstNode.arguments)
  arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AstNode::set_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.AstNode.arguments)
  arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AstNode::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.AstNode.arguments)
}
inline void AstNode::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.arguments)
}
inline ::std::string* AstNode::add_arguments() {
  // @@protoc_insertion_point(field_add_mutable:proto.AstNode.arguments)
  return arguments_.Add();
}
inline void AstNode::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.AstNode.arguments)
}
#if LANG_CXX11
inline void AstNode::add_arguments(::std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.AstNode.arguments)
}
#endif
inline void AstNode::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.AstNode.arguments)
}
inline void AstNode::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.AstNode.arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AstNode::arguments() const {
  // @@protoc_insertion_point(field_list:proto.AstNode.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AstNode::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:proto.AstNode.arguments)
  return &arguments_;
}

// string source = 10;
inline void AstNode::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstNode::source() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.source)
  return source_.GetNoArena();
}
inline void AstNode::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstNode.source)
}
#if LANG_CXX11
inline void AstNode::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstNode.source)
}
#endif
inline void AstNode::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstNode.source)
}
inline void AstNode::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstNode.source)
}
inline ::std::string* AstNode::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstNode.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstNode::release_source() {
  // @@protoc_insertion_point(field_release:proto.AstNode.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstNode::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.source)
}

// .proto.SourceRange range = 11;
inline bool AstNode::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void AstNode::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) {
    delete range_;
  }
  range_ = NULL;
}
inline const ::proto::SourceRange& AstNode::_internal_range() const {
  return *range_;
}
inline const ::proto::SourceRange& AstNode::range() const {
  const ::proto::SourceRange* p = range_;
  // @@protoc_insertion_point(field_get:proto.AstNode.range)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::SourceRange*>(
      &::proto::_SourceRange_default_instance_);
}
inline ::proto::SourceRange* AstNode::release_range() {
  // @@protoc_insertion_point(field_release:proto.AstNode.range)
  
  ::proto::SourceRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline ::proto::SourceRange* AstNode::mutable_range() {
  
  if (range_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::SourceRange>(GetArenaNoVirtual());
    range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.AstNode.range)
  return range_;
}
inline void AstNode::set_allocated_range(::proto::SourceRange* range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete range_;
  }
  if (range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:proto.AstNode.range)
}

// int32 id = 12;
inline void AstNode::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 AstNode::id() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.id)
  return id_;
}
inline void AstNode::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.id)
}

// .proto.Functionality functionality = 13;
inline void AstNode::clear_functionality() {
  functionality_ = 0;
}
inline ::proto::Functionality AstNode::functionality() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.functionality)
  return static_cast< ::proto::Functionality >(functionality_);
}
inline void AstNode::set_functionality(::proto::Functionality value) {
  
  functionality_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.functionality)
}

// .proto.SourceType source_type = 14;
inline bool AstNode::has_source_type() const {
  return accurate_functionality_case() == kSourceType;
}
inline void AstNode::set_has_source_type() {
  _oneof_case_[0] = kSourceType;
}
inline void AstNode::clear_source_type() {
  if (has_source_type()) {
    accurate_functionality_.source_type_ = 0;
    clear_has_accurate_functionality();
  }
}
inline ::proto::SourceType AstNode::source_type() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.source_type)
  if (has_source_type()) {
    return static_cast< ::proto::SourceType >(accurate_functionality_.source_type_);
  }
  return static_cast< ::proto::SourceType >(0);
}
inline void AstNode::set_source_type(::proto::SourceType value) {
  if (!has_source_type()) {
    clear_accurate_functionality();
    set_has_source_type();
  }
  accurate_functionality_.source_type_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.source_type)
}

// .proto.SinkType sink_type = 15;
inline bool AstNode::has_sink_type() const {
  return accurate_functionality_case() == kSinkType;
}
inline void AstNode::set_has_sink_type() {
  _oneof_case_[0] = kSinkType;
}
inline void AstNode::clear_sink_type() {
  if (has_sink_type()) {
    accurate_functionality_.sink_type_ = 0;
    clear_has_accurate_functionality();
  }
}
inline ::proto::SinkType AstNode::sink_type() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.sink_type)
  if (has_sink_type()) {
    return static_cast< ::proto::SinkType >(accurate_functionality_.sink_type_);
  }
  return static_cast< ::proto::SinkType >(0);
}
inline void AstNode::set_sink_type(::proto::SinkType value) {
  if (!has_sink_type()) {
    clear_accurate_functionality();
    set_has_sink_type();
  }
  accurate_functionality_.sink_type_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.sink_type)
}

// .proto.DangerType danger_type = 16;
inline bool AstNode::has_danger_type() const {
  return accurate_functionality_case() == kDangerType;
}
inline void AstNode::set_has_danger_type() {
  _oneof_case_[0] = kDangerType;
}
inline void AstNode::clear_danger_type() {
  if (has_danger_type()) {
    accurate_functionality_.danger_type_ = 0;
    clear_has_accurate_functionality();
  }
}
inline ::proto::DangerType AstNode::danger_type() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.danger_type)
  if (has_danger_type()) {
    return static_cast< ::proto::DangerType >(accurate_functionality_.danger_type_);
  }
  return static_cast< ::proto::DangerType >(0);
}
inline void AstNode::set_danger_type(::proto::DangerType value) {
  if (!has_danger_type()) {
    clear_accurate_functionality();
    set_has_danger_type();
  }
  accurate_functionality_.danger_type_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.danger_type)
}

// .proto.PropagateType propagate_type = 17;
inline bool AstNode::has_propagate_type() const {
  return accurate_functionality_case() == kPropagateType;
}
inline void AstNode::set_has_propagate_type() {
  _oneof_case_[0] = kPropagateType;
}
inline void AstNode::clear_propagate_type() {
  if (has_propagate_type()) {
    accurate_functionality_.propagate_type_ = 0;
    clear_has_accurate_functionality();
  }
}
inline ::proto::PropagateType AstNode::propagate_type() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.propagate_type)
  if (has_propagate_type()) {
    return static_cast< ::proto::PropagateType >(accurate_functionality_.propagate_type_);
  }
  return static_cast< ::proto::PropagateType >(0);
}
inline void AstNode::set_propagate_type(::proto::PropagateType value) {
  if (!has_propagate_type()) {
    clear_accurate_functionality();
    set_has_propagate_type();
  }
  accurate_functionality_.propagate_type_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.propagate_type)
}

// repeated .proto.AstNode child_nodes = 18;
inline int AstNode::child_nodes_size() const {
  return child_nodes_.size();
}
inline void AstNode::clear_child_nodes() {
  child_nodes_.Clear();
}
inline ::proto::AstNode* AstNode::mutable_child_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AstNode.child_nodes)
  return child_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
AstNode::mutable_child_nodes() {
  // @@protoc_insertion_point(field_mutable_list:proto.AstNode.child_nodes)
  return &child_nodes_;
}
inline const ::proto::AstNode& AstNode::child_nodes(int index) const {
  // @@protoc_insertion_point(field_get:proto.AstNode.child_nodes)
  return child_nodes_.Get(index);
}
inline ::proto::AstNode* AstNode::add_child_nodes() {
  // @@protoc_insertion_point(field_add:proto.AstNode.child_nodes)
  return child_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
AstNode::child_nodes() const {
  // @@protoc_insertion_point(field_list:proto.AstNode.child_nodes)
  return child_nodes_;
}

// bool instantiatable = 19;
inline void AstNode::clear_instantiatable() {
  instantiatable_ = false;
}
inline bool AstNode::instantiatable() const {
  // @@protoc_insertion_point(field_get:proto.AstNode.instantiatable)
  return instantiatable_;
}
inline void AstNode::set_instantiatable(bool value) {
  
  instantiatable_ = value;
  // @@protoc_insertion_point(field_set:proto.AstNode.instantiatable)
}

inline bool AstNode::has_accurate_functionality() const {
  return accurate_functionality_case() != ACCURATE_FUNCTIONALITY_NOT_SET;
}
inline void AstNode::clear_has_accurate_functionality() {
  _oneof_case_[0] = ACCURATE_FUNCTIONALITY_NOT_SET;
}
inline AstNode::AccurateFunctionalityCase AstNode::accurate_functionality_case() const {
  return AstNode::AccurateFunctionalityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AstLookupConfig

// repeated .proto.AstNode apis = 1;
inline int AstLookupConfig::apis_size() const {
  return apis_.size();
}
inline void AstLookupConfig::clear_apis() {
  apis_.Clear();
}
inline ::proto::AstNode* AstLookupConfig::mutable_apis(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AstLookupConfig.apis)
  return apis_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
AstLookupConfig::mutable_apis() {
  // @@protoc_insertion_point(field_mutable_list:proto.AstLookupConfig.apis)
  return &apis_;
}
inline const ::proto::AstNode& AstLookupConfig::apis(int index) const {
  // @@protoc_insertion_point(field_get:proto.AstLookupConfig.apis)
  return apis_.Get(index);
}
inline ::proto::AstNode* AstLookupConfig::add_apis() {
  // @@protoc_insertion_point(field_add:proto.AstLookupConfig.apis)
  return apis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
AstLookupConfig::apis() const {
  // @@protoc_insertion_point(field_list:proto.AstLookupConfig.apis)
  return apis_;
}

// bool save_feature = 2;
inline void AstLookupConfig::clear_save_feature() {
  save_feature_ = false;
}
inline bool AstLookupConfig::save_feature() const {
  // @@protoc_insertion_point(field_get:proto.AstLookupConfig.save_feature)
  return save_feature_;
}
inline void AstLookupConfig::set_save_feature(bool value) {
  
  save_feature_ = value;
  // @@protoc_insertion_point(field_set:proto.AstLookupConfig.save_feature)
}

// string smt_formula = 3;
inline void AstLookupConfig::clear_smt_formula() {
  smt_formula_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AstLookupConfig::smt_formula() const {
  // @@protoc_insertion_point(field_get:proto.AstLookupConfig.smt_formula)
  return smt_formula_.GetNoArena();
}
inline void AstLookupConfig::set_smt_formula(const ::std::string& value) {
  
  smt_formula_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AstLookupConfig.smt_formula)
}
#if LANG_CXX11
inline void AstLookupConfig::set_smt_formula(::std::string&& value) {
  
  smt_formula_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AstLookupConfig.smt_formula)
}
#endif
inline void AstLookupConfig::set_smt_formula(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  smt_formula_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AstLookupConfig.smt_formula)
}
inline void AstLookupConfig::set_smt_formula(const char* value, size_t size) {
  
  smt_formula_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AstLookupConfig.smt_formula)
}
inline ::std::string* AstLookupConfig::mutable_smt_formula() {
  
  // @@protoc_insertion_point(field_mutable:proto.AstLookupConfig.smt_formula)
  return smt_formula_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AstLookupConfig::release_smt_formula() {
  // @@protoc_insertion_point(field_release:proto.AstLookupConfig.smt_formula)
  
  return smt_formula_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AstLookupConfig::set_allocated_smt_formula(::std::string* smt_formula) {
  if (smt_formula != NULL) {
    
  } else {
    
  }
  smt_formula_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), smt_formula);
  // @@protoc_insertion_point(field_set_allocated:proto.AstLookupConfig.smt_formula)
}

// bool smt_satisfied = 4;
inline void AstLookupConfig::clear_smt_satisfied() {
  smt_satisfied_ = false;
}
inline bool AstLookupConfig::smt_satisfied() const {
  // @@protoc_insertion_point(field_get:proto.AstLookupConfig.smt_satisfied)
  return smt_satisfied_;
}
inline void AstLookupConfig::set_smt_satisfied(bool value) {
  
  smt_satisfied_ = value;
  // @@protoc_insertion_point(field_set:proto.AstLookupConfig.smt_satisfied)
}

// bool func_only = 5;
inline void AstLookupConfig::clear_func_only() {
  func_only_ = false;
}
inline bool AstLookupConfig::func_only() const {
  // @@protoc_insertion_point(field_get:proto.AstLookupConfig.func_only)
  return func_only_;
}
inline void AstLookupConfig::set_func_only(bool value) {
  
  func_only_ = value;
  // @@protoc_insertion_point(field_set:proto.AstLookupConfig.func_only)
}

// -------------------------------------------------------------------

// PkgAstResult

// string pkg_name = 1;
inline void PkgAstResult::clear_pkg_name() {
  pkg_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PkgAstResult::pkg_name() const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.pkg_name)
  return pkg_name_.GetNoArena();
}
inline void PkgAstResult::set_pkg_name(const ::std::string& value) {
  
  pkg_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PkgAstResult.pkg_name)
}
#if LANG_CXX11
inline void PkgAstResult::set_pkg_name(::std::string&& value) {
  
  pkg_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PkgAstResult.pkg_name)
}
#endif
inline void PkgAstResult::set_pkg_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pkg_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PkgAstResult.pkg_name)
}
inline void PkgAstResult::set_pkg_name(const char* value, size_t size) {
  
  pkg_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PkgAstResult.pkg_name)
}
inline ::std::string* PkgAstResult::mutable_pkg_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResult.pkg_name)
  return pkg_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PkgAstResult::release_pkg_name() {
  // @@protoc_insertion_point(field_release:proto.PkgAstResult.pkg_name)
  
  return pkg_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PkgAstResult::set_allocated_pkg_name(::std::string* pkg_name) {
  if (pkg_name != NULL) {
    
  } else {
    
  }
  pkg_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pkg_name);
  // @@protoc_insertion_point(field_set_allocated:proto.PkgAstResult.pkg_name)
}

// string pkg_version = 2;
inline void PkgAstResult::clear_pkg_version() {
  pkg_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PkgAstResult::pkg_version() const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.pkg_version)
  return pkg_version_.GetNoArena();
}
inline void PkgAstResult::set_pkg_version(const ::std::string& value) {
  
  pkg_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PkgAstResult.pkg_version)
}
#if LANG_CXX11
inline void PkgAstResult::set_pkg_version(::std::string&& value) {
  
  pkg_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PkgAstResult.pkg_version)
}
#endif
inline void PkgAstResult::set_pkg_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pkg_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PkgAstResult.pkg_version)
}
inline void PkgAstResult::set_pkg_version(const char* value, size_t size) {
  
  pkg_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PkgAstResult.pkg_version)
}
inline ::std::string* PkgAstResult::mutable_pkg_version() {
  
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResult.pkg_version)
  return pkg_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PkgAstResult::release_pkg_version() {
  // @@protoc_insertion_point(field_release:proto.PkgAstResult.pkg_version)
  
  return pkg_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PkgAstResult::set_allocated_pkg_version(::std::string* pkg_version) {
  if (pkg_version != NULL) {
    
  } else {
    
  }
  pkg_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pkg_version);
  // @@protoc_insertion_point(field_set_allocated:proto.PkgAstResult.pkg_version)
}

// .proto.Language language = 3;
inline void PkgAstResult::clear_language() {
  language_ = 0;
}
inline ::proto::Language PkgAstResult::language() const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.language)
  return static_cast< ::proto::Language >(language_);
}
inline void PkgAstResult::set_language(::proto::Language value) {
  
  language_ = value;
  // @@protoc_insertion_point(field_set:proto.PkgAstResult.language)
}

// string input_path = 4;
inline void PkgAstResult::clear_input_path() {
  input_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PkgAstResult::input_path() const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.input_path)
  return input_path_.GetNoArena();
}
inline void PkgAstResult::set_input_path(const ::std::string& value) {
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.PkgAstResult.input_path)
}
#if LANG_CXX11
inline void PkgAstResult::set_input_path(::std::string&& value) {
  
  input_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.PkgAstResult.input_path)
}
#endif
inline void PkgAstResult::set_input_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.PkgAstResult.input_path)
}
inline void PkgAstResult::set_input_path(const char* value, size_t size) {
  
  input_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.PkgAstResult.input_path)
}
inline ::std::string* PkgAstResult::mutable_input_path() {
  
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResult.input_path)
  return input_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PkgAstResult::release_input_path() {
  // @@protoc_insertion_point(field_release:proto.PkgAstResult.input_path)
  
  return input_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PkgAstResult::set_allocated_input_path(::std::string* input_path) {
  if (input_path != NULL) {
    
  } else {
    
  }
  input_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_path);
  // @@protoc_insertion_point(field_set_allocated:proto.PkgAstResult.input_path)
}

// .proto.AstLookupConfig config = 5;
inline bool PkgAstResult::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void PkgAstResult::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::proto::AstLookupConfig& PkgAstResult::_internal_config() const {
  return *config_;
}
inline const ::proto::AstLookupConfig& PkgAstResult::config() const {
  const ::proto::AstLookupConfig* p = config_;
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.config)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::AstLookupConfig*>(
      &::proto::_AstLookupConfig_default_instance_);
}
inline ::proto::AstLookupConfig* PkgAstResult::release_config() {
  // @@protoc_insertion_point(field_release:proto.PkgAstResult.config)
  
  ::proto::AstLookupConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::proto::AstLookupConfig* PkgAstResult::mutable_config() {
  
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::AstLookupConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResult.config)
  return config_;
}
inline void PkgAstResult::set_allocated_config(::proto::AstLookupConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:proto.PkgAstResult.config)
}

// repeated .proto.AstNode api_results = 6;
inline int PkgAstResult::api_results_size() const {
  return api_results_.size();
}
inline void PkgAstResult::clear_api_results() {
  api_results_.Clear();
}
inline ::proto::AstNode* PkgAstResult::mutable_api_results(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResult.api_results)
  return api_results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
PkgAstResult::mutable_api_results() {
  // @@protoc_insertion_point(field_mutable_list:proto.PkgAstResult.api_results)
  return &api_results_;
}
inline const ::proto::AstNode& PkgAstResult::api_results(int index) const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.api_results)
  return api_results_.Get(index);
}
inline ::proto::AstNode* PkgAstResult::add_api_results() {
  // @@protoc_insertion_point(field_add:proto.PkgAstResult.api_results)
  return api_results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
PkgAstResult::api_results() const {
  // @@protoc_insertion_point(field_list:proto.PkgAstResult.api_results)
  return api_results_;
}

// repeated .proto.AstNode root_nodes = 7;
inline int PkgAstResult::root_nodes_size() const {
  return root_nodes_.size();
}
inline void PkgAstResult::clear_root_nodes() {
  root_nodes_.Clear();
}
inline ::proto::AstNode* PkgAstResult::mutable_root_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResult.root_nodes)
  return root_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::AstNode >*
PkgAstResult::mutable_root_nodes() {
  // @@protoc_insertion_point(field_mutable_list:proto.PkgAstResult.root_nodes)
  return &root_nodes_;
}
inline const ::proto::AstNode& PkgAstResult::root_nodes(int index) const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResult.root_nodes)
  return root_nodes_.Get(index);
}
inline ::proto::AstNode* PkgAstResult::add_root_nodes() {
  // @@protoc_insertion_point(field_add:proto.PkgAstResult.root_nodes)
  return root_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::AstNode >&
PkgAstResult::root_nodes() const {
  // @@protoc_insertion_point(field_list:proto.PkgAstResult.root_nodes)
  return root_nodes_;
}

// -------------------------------------------------------------------

// PkgAstResults

// repeated .proto.PkgAstResult pkgs = 1;
inline int PkgAstResults::pkgs_size() const {
  return pkgs_.size();
}
inline void PkgAstResults::clear_pkgs() {
  pkgs_.Clear();
}
inline ::proto::PkgAstResult* PkgAstResults::mutable_pkgs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PkgAstResults.pkgs)
  return pkgs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::PkgAstResult >*
PkgAstResults::mutable_pkgs() {
  // @@protoc_insertion_point(field_mutable_list:proto.PkgAstResults.pkgs)
  return &pkgs_;
}
inline const ::proto::PkgAstResult& PkgAstResults::pkgs(int index) const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResults.pkgs)
  return pkgs_.Get(index);
}
inline ::proto::PkgAstResult* PkgAstResults::add_pkgs() {
  // @@protoc_insertion_point(field_add:proto.PkgAstResults.pkgs)
  return pkgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::PkgAstResult >&
PkgAstResults::pkgs() const {
  // @@protoc_insertion_point(field_list:proto.PkgAstResults.pkgs)
  return pkgs_;
}

// uint64 timestamp = 2;
inline void PkgAstResults::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PkgAstResults::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.PkgAstResults.timestamp)
  return timestamp_;
}
inline void PkgAstResults::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.PkgAstResults.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::AstNode_NodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::AstNode_NodeType>() {
  return ::proto::AstNode_NodeType_descriptor();
}
template <> struct is_proto_enum< ::proto::Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Language>() {
  return ::proto::Language_descriptor();
}
template <> struct is_proto_enum< ::proto::Functionality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Functionality>() {
  return ::proto::Functionality_descriptor();
}
template <> struct is_proto_enum< ::proto::SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::SourceType>() {
  return ::proto::SourceType_descriptor();
}
template <> struct is_proto_enum< ::proto::SinkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::SinkType>() {
  return ::proto::SinkType_descriptor();
}
template <> struct is_proto_enum< ::proto::DangerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::DangerType>() {
  return ::proto::DangerType_descriptor();
}
template <> struct is_proto_enum< ::proto::PropagateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::PropagateType>() {
  return ::proto::PropagateType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ast_2eproto
